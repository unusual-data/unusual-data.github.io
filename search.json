[
  {
    "objectID": "notes/learning/2025/2025-12-git-case-sensitivity/index.html",
    "href": "notes/learning/2025/2025-12-git-case-sensitivity/index.html",
    "title": "Git Deployment: Case Sensitivity 404 Hatası",
    "section": "",
    "text": "Bağlam (Context): Quarto projesinin yerel ortamda (Localhost/Windows) sorunsuz çalışmasına rağmen, GitHub Pages (Linux) ortamına deploy edildikten sonra görsel bütünlüğünün kontrol edilmesi.\nTespit Edilen Hata (Observed Error): Yerel önizlemede (Preview) görüntülenen .png uzantılı görsellerin, canlı sunucuda (Production) yüklenmemesi ve kırık ikon (broken image) olarak görünmesi.\n\nLog Çıktısı: GET https://ibrahimcapar.com/posts/sanal-ayiklama/images/TIA-2.png 404 (Not Found)\n\nSistem Ortamı (Environment):\n\nYazılım: Quarto CLI / Git for Windows\nVersiyon: v1.8.25 (Quarto) / v2.51.2 (Git)\nOS/Donanım:\n\nLocal: Windows 11 (Case-Insensitive)\nHost: Ubuntu Latest (GitHub Actions - Case-Sensitive)"
  },
  {
    "objectID": "notes/learning/2025/2025-12-git-case-sensitivity/index.html#problem-tanımı-problem-description",
    "href": "notes/learning/2025/2025-12-git-case-sensitivity/index.html#problem-tanımı-problem-description",
    "title": "Git Deployment: Case Sensitivity 404 Hatası",
    "section": "",
    "text": "Bağlam (Context): Quarto projesinin yerel ortamda (Localhost/Windows) sorunsuz çalışmasına rağmen, GitHub Pages (Linux) ortamına deploy edildikten sonra görsel bütünlüğünün kontrol edilmesi.\nTespit Edilen Hata (Observed Error): Yerel önizlemede (Preview) görüntülenen .png uzantılı görsellerin, canlı sunucuda (Production) yüklenmemesi ve kırık ikon (broken image) olarak görünmesi.\n\nLog Çıktısı: GET https://ibrahimcapar.com/posts/sanal-ayiklama/images/TIA-2.png 404 (Not Found)\n\nSistem Ortamı (Environment):\n\nYazılım: Quarto CLI / Git for Windows\nVersiyon: v1.8.25 (Quarto) / v2.51.2 (Git)\nOS/Donanım:\n\nLocal: Windows 11 (Case-Insensitive)\nHost: Ubuntu Latest (GitHub Actions - Case-Sensitive)"
  },
  {
    "objectID": "notes/learning/2025/2025-12-git-case-sensitivity/index.html#kök-neden-analizi-root-cause",
    "href": "notes/learning/2025/2025-12-git-case-sensitivity/index.html#kök-neden-analizi-root-cause",
    "title": "Git Deployment: Case Sensitivity 404 Hatası",
    "section": "2 Kök Neden Analizi (Root Cause)",
    "text": "2 Kök Neden Analizi (Root Cause)\n\nTespit (Detection): Deployment sonrası güncellenen ilgili kısmın kontrol edilmesi sonucunda bazı görsellerin kırık ikon olarak göründüğü tespit edilmiştir.\nTeknik Sebep (Technical Cause): Windows işletim sistemi dosya yollarında büyük/küçük harf duyarsızken (Case Insensitive), Linux sunucuların (GitHub Actions) duyarlı (Case Sensitive) olması. Kodda TIA-2.png çağrılırken dosyanın tia-2.png olması."
  },
  {
    "objectID": "notes/learning/2025/2025-12-git-case-sensitivity/index.html#çözüm-uygulaması-resolution",
    "href": "notes/learning/2025/2025-12-git-case-sensitivity/index.html#çözüm-uygulaması-resolution",
    "title": "Git Deployment: Case Sensitivity 404 Hatası",
    "section": "3 Çözüm Uygulaması (Resolution)",
    "text": "3 Çözüm Uygulaması (Resolution)\nSistemi kararlı hale getirmek için uygulanan adımlar:\n\nKontrol İlk önce Git’in klasördeki dosyaları görüp görmediği ve takip edip etmediği kontrol edilmiştir.\n\n\n\n\n\n\n\nNotBASH Kod Bloğu\n\n\n\n\n\n    git status\n    git ls-files sanal-ayiklama/images/\n\n\n\ngit status komutu kaydedilecek bir şey olmadığını ve çalışma ağacının temiz olduğu bilgisini döndürmüştür. Listeleme komutu yaptıktan sonra ilgili resim isimleri büyük harflerle görünmektedir. Örn: TIA-2.png, TIA-3.png şeklinde.\n\nStandartlaştırma (Renaming) Hatalı görsel isimleri web standartlarına (lowercase) uygun hale getirilmiştir. Bu işlemde dosya isimlerine önce tmp ön eki eklenmiştir. Sonrasında ise tmp eki kaldırılarak standart isim formatında yeniden kaydedilmiştir.\n\n\n\n\n\n\n\nNotBASH Kod Bloğu\n\n\n\n\n\n    cd posts/sanal-ayiklama/images/\n    git mv TIA-1.jpg tmp-1.jpg\n    git mv tmp-1.jpg tia-1.jpg\n\n    git mv TIA-2.png tmp-2.png\n    git mv tmp-2.png tia-2.png\n\n    git mv TIA-3.png tmp-3.png\n    git mv tmp-3.png tia-3.png\n\n    git mv TIA-4.png tmp-4.png\n    git mv tmp-4.png tia-4.png\n\n    git mv TIA-5.png tmp-5.png\n    git mv tmp-5.png tia-5.png\n\n    git mv TIA-6.png tmp-6.png\n    git mv tmp-6.png tia-6.png\n\n\n\nİsim düzeltme işlemleri tamamlandıktan sonra ana dizine dönülmüş, değişiklikler commit edilerek uzak sunucuya gönderilmiştir.\n\n\n\n\n\n\nNotBASH Kod Bloğu\n\n\n\n\n\n   cd ../../..\n   git commit -m \"Capitalized image names have been corrected.\"\n   git push origin main\n\n\n\n\n\n\n\n\n\nİpucu\n\n\n\ngit mv komutu dosyanın adını diskte değiştir ve bu değişikliği otomatik olarak “Stage” eder\n\n\n\nDoğrulama (Verification): GitHub Actions pipeline tamamlandıktan sonra tarayıcı önbelleği temizlendi (Ctrl+F5) ve görselin yüklendiği doğrulandı."
  },
  {
    "objectID": "notes/learning/2025/2025-12-git-case-sensitivity/index.html#sonuç-ve-değerlendirme-conclusion",
    "href": "notes/learning/2025/2025-12-git-case-sensitivity/index.html#sonuç-ve-değerlendirme-conclusion",
    "title": "Git Deployment: Case Sensitivity 404 Hatası",
    "section": "4 Sonuç ve Değerlendirme (Conclusion)",
    "text": "4 Sonuç ve Değerlendirme (Conclusion)\n\n\n\n\n\n\nNotÇıkarım\n\n\n\nDosya isimlendirmelerinde platform bağımsızlığını garanti etmek için projeye eklenen bütün resimler daima ‘kebab-case’ (küçük harf ve tire) standardını kullanmalıdır.\n\n\n\n\n      \n        İbrahim Çapar\n        ::\n        27.12.2025"
  },
  {
    "objectID": "notes/references/digital-twin/index.html",
    "href": "notes/references/digital-twin/index.html",
    "title": "Digital Twin",
    "section": "",
    "text": "Bu bölümde Digital Twin ile ilgili teknik notlar yer almaktadır.\n\n\n\n\n\n\n   \n    \n    \n      Sıralama Öğesi\n      Varsayılan\n      \n        Son Güncelleme - En eski\n      \n      \n        Son Güncelleme - En yeni\n      \n      \n        Konu / Doküman\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nKonu / Doküman\n\n\n\nSistem / Rev\n\n\n\nEtiketler\n\n\n\nSon Güncelleme\n\n\n\n\n\n\n\n\nVisual Components İpuçları\n\n\nVC 4.10 / Rev.01\n\n\nVisual Components\n\n\n27.12.2025\n\n\n\n\n\n\nEşleşen öğe yok"
  },
  {
    "objectID": "notes/references/index.html",
    "href": "notes/references/index.html",
    "title": "Teknik Referanslar",
    "section": "",
    "text": "Bu bölümde, mühendislik disiplinlerine dair kalıcı teknik bilgiler ve referans dökümanları yer almaktadır.\n\n\n\n\n\n\n   \n    \n    \n      Sıralama Öğesi\n      Varsayılan\n      \n        Son Güncelleme - En eski\n      \n      \n        Son Güncelleme - En yeni\n      \n      \n        Konu / Not\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nKonu / Not\n\n\n\nSistem / Rev\n\n\n\nEtiketler\n\n\n\nSon Güncelleme\n\n\n\n\n\n\n\n\nVisual Components İpuçları\n\n\nVC 4.10 / Rev.01\n\n\nVisual Components\n\n\n27.12.2025\n\n\n\n\n\n\nEşleşen öğe yok"
  },
  {
    "objectID": "posts/visual-components-layout/index.html",
    "href": "posts/visual-components-layout/index.html",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "",
    "text": "Endüstriyel otomasyon, Robotik ve Dijital İkiz (Digital Twin) alanında yetkinliklerimi geliştirmek için Visual Components programını öğrenmeye başladım. Bu yazıda, Visual Component Academy de bulunan Layout Configuration dersini takip ederek oluşturduğum ilk düzenlemeyi paylaşıyorum."
  },
  {
    "objectID": "posts/visual-components-layout/index.html#giriş",
    "href": "posts/visual-components-layout/index.html#giriş",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "",
    "text": "Endüstriyel otomasyon, Robotik ve Dijital İkiz (Digital Twin) alanında yetkinliklerimi geliştirmek için Visual Components programını öğrenmeye başladım. Bu yazıda, Visual Component Academy de bulunan Layout Configuration dersini takip ederek oluşturduğum ilk düzenlemeyi paylaşıyorum."
  },
  {
    "objectID": "posts/visual-components-layout/index.html#neler-yaptım",
    "href": "posts/visual-components-layout/index.html#neler-yaptım",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "Neler Yaptım?",
    "text": "Neler Yaptım?\nBu çalışmada temel olarak şu adımları uyguladım:\n\ne-Catalog Kullanımı: Kütüphaneden konveyör, besleyici (Feeder), eklemli robot (Articulated Robot), torna tezgahı (Lathe), fens (Fence), masa (Table) ve rafların (Warehouse Shelf) sahneye eklenmesi.\nPnP (Plug and Play): Bileşenlerin birbirine otomatik olarak bağlanması ve hizalanması.\nLayout Düzenleme: Eklenen bileşenlerin “Clone” ile çoğaltılması, “Move” ile yerleşimlerin ayarlanması, bileşen ayarları (Component Properties) kullanarak bileşenlerin açılarının ayarlanması.\nProcess Flow Editor: Oluşturulan senaryoda prosesin hangi işlem sırası ile gerçekleştirileceğinin ayarlanması.\nInteract: Sahneye eklenen robotun eksen hareketlerinin mause ile hareket ettirilerek çalışma uzayının (Work Envelope) incelenmesi.\nStatements: Oluşturulan senaryo kapsamında konveyör hattından gelen Piston Head ile raftan alınan Piston Rod bileşenlerinin, Process Node kullanılarak A masasında montajının yapılması, ardından B masasında son işlemlerin tamamlanarak ürünün sistemden çıkışının sağlanması.\nSimülasyon Testi: Oluşturulan senaryonun gözlemlenmesi ve hataların giderilmesi."
  },
  {
    "objectID": "posts/visual-components-layout/index.html#ekran-görüntüsü",
    "href": "posts/visual-components-layout/index.html#ekran-görüntüsü",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "Ekran Görüntüsü",
    "text": "Ekran Görüntüsü\nAşağıda kendi oluşturduğum simülasyonun görüntüsü yer almaktadır:"
  },
  {
    "objectID": "posts/visual-components-layout/index.html#simülasyon-adımları",
    "href": "posts/visual-components-layout/index.html#simülasyon-adımları",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "Simülasyon Adımları",
    "text": "Simülasyon Adımları"
  },
  {
    "objectID": "posts/visual-components-layout/index.html#çıkarımlarım-key-takeaways",
    "href": "posts/visual-components-layout/index.html#çıkarımlarım-key-takeaways",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "Çıkarımlarım (Key Takeaways)",
    "text": "Çıkarımlarım (Key Takeaways)\n\nVisual Components’in manuel pozisyonlama yerine PnP (Plug and Play) özelliği tasarım sürecini kolaylaştırıyor. Ayrıca “Snap” özelliği ile bileşenleri birbiriyle kolay bir şekilde birleştirilmesini sağlıyor.\nVisual Components’in içerisinde bulunan e-Catalog ile birçok önemli markalara ait ürünlerin aynı ortamda bulunması gerçek durumları simüle etmeyi kolaylaştırıyor.\nProcess Flow Editor ile, layoutta bulunan bileşenlerin prosesi hangi sıra ve ilişki ile gerçekleştireceği kolay bir şekilde yönetiliyor. Bununla birlikte “Statement” kullanarak daha gelişmiş sonuçlar elde edilebiliyor.\nDijital İkiz yaklaşımına insan bileşenini de üretim sürecine dahil ederek prosesi daha gelişmiş bir şekilde simüle edilmesini sağlıyor.\n\n\nKaynak: Bu çalışma Visual Components Academy dersleri baz alınarak yapılmıştır.\n\n\n      \n        İbrahim Çapar\n        ::\n        11 Aralık 2025"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "İbrahim Çapar",
    "section": "",
    "text": "Elektrik-Elektronik Mühendisi\nEndüstriyel otomasyon, robotik ve görüntü işleme sistemlerini; modern yazılım mimarileri ve sürdürülebilir kod standartlarıyla projelendiriyorum. Bu platform; uygulama odaklı çalışmalarımın, teknik araştırmalarımın ve mühendislik dökümantasyonlarımın teknik referans veritabanıdır."
  },
  {
    "objectID": "index.html#hakkımda",
    "href": "index.html#hakkımda",
    "title": "İbrahim Çapar",
    "section": "",
    "text": "Elektrik-Elektronik Mühendisi\nEndüstriyel otomasyon, robotik ve görüntü işleme sistemlerini; modern yazılım mimarileri ve sürdürülebilir kod standartlarıyla projelendiriyorum. Bu platform; uygulama odaklı çalışmalarımın, teknik araştırmalarımın ve mühendislik dökümantasyonlarımın teknik referans veritabanıdır."
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Mühendislik Projeleri",
    "section": "",
    "text": "Sıralama Öğesi\n      Varsayılan\n      \n        Başlık\n      \n      \n        Tarih - En eski\n      \n      \n        Tarih - En yeni\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nST Programlama ile Sıralı Motor Kontrolü\n\n6 dakika\n\n\nEndüstriyel Otomasyon\n\nPLC\n\nCODESYS\n\nVisu\n\nST\n\n\n\n\n12 Ocak 2026\n\n\n\n\n\n\n\n\n\n\n\n\n\nSanal Ayıklama Sistemi\n\n7 dakika\n\n\nEndüstriyel Otomasyon\n\nGörüntü İşleme\n\nTIA Portal\n\nPLCSIM\n\nPLC\n\nFactoryIO\n\nPython\n\nST\n\n\n\n\n23 Aralık 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nCODESYS Tabanlı Trafik Işığı Kontrol Sistemi\n\n7 dakika\n\n\nEndüstriyel Otomasyon\n\nPLC\n\nCODESYS\n\nVisu\n\nST\n\n\n\n\n20 Aralık 2025\n\n\n\n\n\n\nEşleşen öğe yok"
  },
  {
    "objectID": "projects/virtual-sorting/index.html",
    "href": "projects/virtual-sorting/index.html",
    "title": "Sanal Ayıklama Sistemi",
    "section": "",
    "text": "Kategori\nDetay\n\n\n\n\nAlan\nEndüstriyel Otomasyon\n\n\nMimari & Metodoloji\nSanal Donanım Döngüsü (SIL), Görüntü İşleme, Snap7 Haberleşme\n\n\nTeknolojiler\nTIA Portal V20, PLCSIM V20, Factory I/O, Python\n\n\nUygulama Odağı\nNesne Sınıflandırma\n\n\nKaynak\nGitHub’da İncele & Projeyi İndir (.zip)"
  },
  {
    "objectID": "projects/virtual-sorting/index.html#proje-künyesi",
    "href": "projects/virtual-sorting/index.html#proje-künyesi",
    "title": "Sanal Ayıklama Sistemi",
    "section": "",
    "text": "Kategori\nDetay\n\n\n\n\nAlan\nEndüstriyel Otomasyon\n\n\nMimari & Metodoloji\nSanal Donanım Döngüsü (SIL), Görüntü İşleme, Snap7 Haberleşme\n\n\nTeknolojiler\nTIA Portal V20, PLCSIM V20, Factory I/O, Python\n\n\nUygulama Odağı\nNesne Sınıflandırma\n\n\nKaynak\nGitHub’da İncele & Projeyi İndir (.zip)"
  },
  {
    "objectID": "projects/virtual-sorting/index.html#genel-bakış-ve-problem-tanımı",
    "href": "projects/virtual-sorting/index.html#genel-bakış-ve-problem-tanımı",
    "title": "Sanal Ayıklama Sistemi",
    "section": "2. Genel Bakış ve Problem Tanımı",
    "text": "2. Genel Bakış ve Problem Tanımı\n\n2.1. Proje Amacı\nBu projenin amacı, Python ve Snap7 kütüphanesi kullanarak Factory IO ortamında sanal ayıklama sistemini PLC kontrolüyle gerçekleştirmektir.\n\n\n2.2. Problem\nSanal PLC kullanarak Factory IO ortamında kurulan konveyör hattında nesnelerin renklerine göre sınıflandırma simülasyonu yapılırken şu sorunlarla karşılaşılmıştır:\n\nSanal PLC: Fiziksel bir PLC kullanmadan görüntü işlemeden gelen sonuca göre PLC kodunun Factory IO ortamıyla etkileşim kurması gerekmektedir.\nGörüntü İşleme: Factory IO ortamında nesnelerin renklerine göre ayrılabilmesi için -vision sensör kullanmadan- görüntü işleme yapılması gerekmektedir.\nHaberleşme: Görüntü işleme sonucuna göre işlem yapılabilmesi için görüntü işleme kodu ile PLC’nin haberleşmesi gerekmektedir.\n\n\n\n2.3. Çözüm ve Yaklaşım\nBelirtilen problemleri çözmek için python programlama ile PLCSIM programı kullanılmıştır.\n\nFactory IO ortamıyla PLC’nin simüle edilebilmesi için PLCSIM V20 kullanılmıştır. Factory IO direkt olarak PLCSIM ile haberleşebilmektedir.\nNesnelerin renklerine göre ayrılabilmesi için vision sensör kullanmadan ayrım yapılabilmesi için görüntü olması gerekmektedir. Simülasyon ekranında görüntü anlık olarak python ile işlenip elde edilen sonuca göre PLC’ye çıkış yazılmıştır.\nGörüntü işleme sonucunda elde edilen bilgi Snap7 kütüphanesi kullanılarak PLC ile haberleşmesi sağlanmıştır."
  },
  {
    "objectID": "projects/virtual-sorting/index.html#sistem-mimarisi-ve-tasarım",
    "href": "projects/virtual-sorting/index.html#sistem-mimarisi-ve-tasarım",
    "title": "Sanal Ayıklama Sistemi",
    "section": "3. Sistem Mimarisi ve Tasarım",
    "text": "3. Sistem Mimarisi ve Tasarım\nBu projede PLC programı TIA Portal V20 kullanılarak Ladder (LD) diyagramı olarak hazırlanmıştır. Hazırlanan bu PLC programının Factory IO ile haberleşebilmesi için PLCSIM V20 kullanılmıştır. Factory IO ortamında konveyör, pusher ve diğer bileşenler senaryoya uygun yerleştirilmiştir. Factory IO ortamında görüntü işleme OpenCV kütüphanesi ile gerçekleştirilmiştir. Factory IO’da görüntü elde etmek için bir kamera bulunmadığından simülasyon ekranı tamamen bir görüntü olarak değerlendirilmiştir. Bu işlem mss kütüphanesi ile yapılmıştır. Oluşturulan python kodunun PLC ile haberleşmesini sağlamak için snap7 kütüphanesi kullanılmıştır. Program yapısında bulunan matris işlemleri için numpy, zaman işlemleri için time kütüphanesi kullanılmıştır.\n\n3.1. Algoritma ve İşleyiş Mantığı\nSistem çalışmasını Factory IO ekranında gerçekleştirmektedir. Factory IO ortamında kurulan konveyör sistemi, Start butonuna basınca çalışmaya başlamaktadır. Herhangi bir anda Stop ve Acil Stop butonuna basılmasıyla sistem tamamen durmaktadır. Tekrar Start butonu basılması durumunda çalışmasına kaldığı yerden devam etmektedir. Kurulan sistemin başlangıç kısmında Mavi ve Yeşil ham madde konveyöre rastgele olarak koyulmaktadır. Birinci kontrol noktasında Mavi Hammadde görülmesi durumunda Pusher-1 aktif olarak Mavi Hammadde’yi ileri doğru ittirmektedir. İkinci kontrol noktasında Yeşil Hammadde görülmesi durumunda Pusher-2 aktif olarak Yeşil Hammadde ileri doğru itilmektedir. Hammaddeler sınıflandırınca sistem çalışmasını tamamlamaktadır.\n\n\n3.2. Teknik Yaklaşım\n\nOluşturulan sistemin görüntü işleme ve PLC ile haberleşmesini sağlamak için Python programlama tercih edilmiştir. Böylelikle Snap7 kütüphanesi ile Siemens PLC arasında haberleşme kurulurken, aynı zamanda OpenCV ile de görüntü işleme gerçekleştirilmiştir. Factory IO ortamında kamera görüntüsü alınamadığı için, simülasyon ekranı kullanılmıştır. Oluşturulan sahnede, her iki noktaya gören bir bakış açısıyla görüntü sabitlenmiştir. Kontrolün yapılacağı noktalar ilgi alanı (Region of Interest - ROI) olarak koordinatları belirlenmiştir. Bu koordinatların programa girilmesiyle renk kontrolleri sadece bu noktada yapılmıştır.\nSistemde renkleri ayırt etmek için Hue,Saturation,Value (HSV) uzayı kullanılmıştır. Ayrım yapılacak renkler bu uzayda alt ve üst limitler şeklinde numpy array olarak tanımlanmıştır. Ekrandan alınan görüntüler BGR formatından HSV formatına dönüştürülmüştür. Belirlenen HSV aralığına giren pikseller beyaz, girmeyenler siyah yapılarak bir maske (binary image) elde edilmiştir. Daha sonra oluşturulan bu maske üzerindeki beyaz pikseller yani aralığa giren değerler sayılarak eşik değeri ile karşılaştırılmıştır. Eşik değeri aşılması durumunda da karşılaştırma sonucu ilgili değişken boolean veri tipinde true olmaktadır. Bu veri de Snap7 kütüphanesi aracılığıyla PLC’nin belirlen bitine yazılmıştır."
  },
  {
    "objectID": "projects/virtual-sorting/index.html#uygulama-ve-kod-detayları",
    "href": "projects/virtual-sorting/index.html#uygulama-ve-kod-detayları",
    "title": "Sanal Ayıklama Sistemi",
    "section": "4. Uygulama ve Kod Detayları",
    "text": "4. Uygulama ve Kod Detayları\nSistemin çalışmasını sağlayan Python kodu sade, yalın ve modüler bir şekilde yazılmıştır. Snap7 kütüphanesi ile PLCSIM arasındaki iletişimi NetToPLCSim uygulaması sağlamaktadır. PLCSIM sanal ortamda çalıştığı için bu program aracılığıyla IP adresi ve port üzerinden bağlantı kurabilmektedir.\n\n4.1. Değişken ve Tanımlar\nProgramın sağlıklı işleyebilmesi için ön tanımlı değerlerin tanımlanması gerekmektedir. İlk olarak ayrım yapacağımız rengin HSV uzayındaki alt ve üst değerleri tanımlanmıştır. Daha sonrasında simülasyon ekranında renk kontrolünün yapılacağı bölgelerin (ROI) koordinatı belirlenerek tanımlanmıştır. Oluşturulan maske görüntüsünde (beyaz ve siyah piksellerden oluşan) hangi değerin üstünde olursa sonucu true olacağını belirlemek için bir eşik değeri (treshold) tanımlanmıştır. Simülasyon sürekli bir hareket olduğu için gecen_süre değişkeni ile de döngü çevrim süresi (Cycle Time) belirlenmiştir. Her 0.10 saniyede (100 ms) yani saniyede 10 döngü çalışması sağlanmıştır.\n\n\n\n\n\n\nNotÖn Tanımlı Değerler\n\n\n\n\n\nblue_low   = np.array([75,  30, 20])\nblue_hıgh  = np.array([140, 255, 255])\n\ngreen_low  = np.array([40,  80, 50])\ngreen_hıgh = np.array([80,  255, 255])\n\nroı_blue = {'top': 432, 'left': 692, 'width': 48, 'height': 44}\nroı_green = {'top': 565, 'left': 1253, 'width': 50, 'height': 68}\n\npx_threshold = 1200\ngecen_sure = 0.10\n\n\n\n\n\n4.2. Algoritma ve Kod Mantığı\nProjenin ana yapısını OpenCV kütüphanesine ait görüntü işleme komutları ile bu komutların PLC’ye yazılmasını sağlayan Snap7 komutları oluşturmaktadır. PLC programlamada yazılan ladder diyagramında M50.0 ve M51.0 biti kullanılmıştır.\n\n\n\n\n\n\nNotGörüntü İşleme\n\n\n\n\n\n        img_b = np.array(scr.grab(roı_blue))[:, :, :3]\n        img_g = np.array(scr.grab(roı_green))[:, :, :3]\n\n        hsv_b = cv2.cvtColor(img_b, cv2.COLOR_BGR2HSV)\n        hsv_g = cv2.cvtColor(img_g, cv2.COLOR_BGR2HSV)\n\n        blue_mask  = cv2.inRange(hsv_b, blue_low, blue_hıgh)\n        green_mask = cv2.inRange(hsv_g, green_low, green_hıgh)\n\n        blue_px  = cv2.countNonZero(blue_mask)\n        green_px = cv2.countNonZero(green_mask)\n\n\n\n\n\n\n\n\n\nNotKarar Mekanizması\n\n\n\n\n\n        blue  = blue_px  &gt; px_threshold\n        green = green_px &gt; px_threshold\n\n\n\n\n\n\n\n\n\nNotPLC'ye veri yazma\n\n\n\n\n\n        byte_blue = bytearray(plc.mb_read(50, 1))\n        util.set_bool(byte_blue, 0, 0, blue)\n        plc.mb_write(50, 1, byte_blue)\n        \n        byte_green = bytearray(plc.mb_read(51, 1))\n        util.set_bool(byte_green, 0, 0, green)\n        plc.mb_write(51, 1, byte_green)"
  },
  {
    "objectID": "projects/virtual-sorting/index.html#karşılaşılan-teknik-zorluklar-ve-çözüm-süreçleri",
    "href": "projects/virtual-sorting/index.html#karşılaşılan-teknik-zorluklar-ve-çözüm-süreçleri",
    "title": "Sanal Ayıklama Sistemi",
    "section": "5. Karşılaşılan Teknik Zorluklar ve Çözüm Süreçleri",
    "text": "5. Karşılaşılan Teknik Zorluklar ve Çözüm Süreçleri\n\n5.1. Ekrandan Görüntü Alma\nProblem: Konveyörde bulunan ürünlerin renklere göre sınıflandırılması için görüntü elde edilmesi gerekmektedir.\nÇözüm: mss kütüphanesi kullanılarak simülasyon ekranı canlı görüntü olarak kullanılmış bu ekran üzerinden görüntüye yapılan işlemler sonucunda değer elde edilmiştir.\n\n\n5.2. ROI Belirleme\nProblem: Elde edilen görüntüye ilgili görüntü işlemi yapılarak sonuç üretilmesi gerekmektedir. Ancak mss kütüphanesi ile bütün ekran görüntü olarak kullanılmaktadır.\nÇözüm: İlgi alanı (ROI) kavramı kullanılarak, görüntünün alınması istenilen bölge önceden tanımlanmıştır. Bunun için Factory IO ortamında bütün sahneyi gören sabit bir noktada kamera açısı oluşturulmuştur. ROI koordinatı yine aynı kütüphane kullanılarak görüntünün alınacağı bölgenin ekranda nereye karşılık geldiği bulunmuştur.\n\n\n\n\n\n\nNotROI Belirleme\n\n\n\n\n\nimport cv2\nimport mss\nimport numpy as np\n\nwith mss.mss() as sct:\n    screenshot = np.array(sct.grab(sct.monitors[1]))\n    img = cv2.cvtColor(screenshot, cv2.COLOR_BGRA2BGR)\n\nroi = cv2.selectROI(\"ROI Sec (Enter = Onay, Esc = Iptal)\", img, False)\ncv2.destroyAllWindows()\n\nx, y, w, h = roi\nprint(f'screen_area = {{\"top\": {y}, \"left\": {x}, \"width\": {w}, \"height\": {h}}}')"
  },
  {
    "objectID": "projects/virtual-sorting/index.html#sonuç",
    "href": "projects/virtual-sorting/index.html#sonuç",
    "title": "Sanal Ayıklama Sistemi",
    "section": "6. Sonuç",
    "text": "6. Sonuç\nBu projede hiçbir fiziksel donanım gereksinimi duymadan bir görüntü işleme algoritması çalıştırılmıştır. Sistemin çalışması Python programlamaya dayanmaktadır. OpenCV ve Snap7 kütüphaneleri ile tamamen simülasyon ortamında gerekli haberleşme ve veri yazma komutları kullanılarak gerçek senaryoya uygun renk tespitine göre sınıflandırma çalışması yapılmıştır.\nProje Çıktıları:\n\nSanal Devreye Alma: Projede gerçek donanım kullanılmadan PLCSIM, Factory IO ve NetToPLCSim uygulamaları aracılığıyla ilgili haberleşme ayarları yapılarak nesneleri renklerine göre sınıflandırma simülasyon çalışması yapılmıştır.\nModülerlik: Hazırlanan kod modüler bir yapıda yönetilebilir bir şekilde hazırlanmıştır. Renk tespiti HSV uzayında ön tanımlı değer olarak belirlenmiş, veri yazma noktasında util.set_bool komutu ile sadece PLC’nin ilgili bitine veri yazılmıştır. Görüntü sadece ekranda belirlenen koordinatta (ROI) işlenmiştir. Böylelikle renk değişimi, farklı bir noktada görüntü işleme ve PLC’nin istenilen başka bitlerine de veri yazma işlemleri kolaylıkla yapılabilmektedir."
  },
  {
    "objectID": "projects/virtual-sorting/index.html#referanslar-ve-kaynakça",
    "href": "projects/virtual-sorting/index.html#referanslar-ve-kaynakça",
    "title": "Sanal Ayıklama Sistemi",
    "section": "7. Referanslar ve Kaynakça",
    "text": "7. Referanslar ve Kaynakça\nProje sürecinde yararlanılan teknik dokümanlar ve araçlar aşağıdadır:\n\nDokümantasyon: OpenCV | Snap7 | mss | time\nGitHub Deposu: unusual-data/virtual-sorting\nDoğrudan İndir İndir (.zip)\n\n\n\n      \n        İbrahim Çapar\n        ::\n        23 Aralık 2025"
  },
  {
    "objectID": "projects/traffic-lights-codesys/index.html",
    "href": "projects/traffic-lights-codesys/index.html",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "",
    "text": "Kategori\nDetay\n\n\n\n\nAlan\nEndüstriyel Otomasyon\n\n\nMimari & Metodoloji\nSonlu Durum Makinesi (FSM)\n\n\nTeknolojiler\nCODESYS V3.5, Structured Text (ST), TargetVisu\n\n\nUygulama Odağı\nAkıllı Kavşak Yönetimi\n\n\nKaynak\nGitHub’da İncele & Projeyi İndir (.zip)"
  },
  {
    "objectID": "projects/traffic-lights-codesys/index.html#proje-künyesi",
    "href": "projects/traffic-lights-codesys/index.html#proje-künyesi",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "",
    "text": "Kategori\nDetay\n\n\n\n\nAlan\nEndüstriyel Otomasyon\n\n\nMimari & Metodoloji\nSonlu Durum Makinesi (FSM)\n\n\nTeknolojiler\nCODESYS V3.5, Structured Text (ST), TargetVisu\n\n\nUygulama Odağı\nAkıllı Kavşak Yönetimi\n\n\nKaynak\nGitHub’da İncele & Projeyi İndir (.zip)"
  },
  {
    "objectID": "projects/traffic-lights-codesys/index.html#genel-bakış-ve-problem-tanımı",
    "href": "projects/traffic-lights-codesys/index.html#genel-bakış-ve-problem-tanımı",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "2. Genel Bakış ve Problem Tanımı",
    "text": "2. Genel Bakış ve Problem Tanımı\n\n2.1. Proje Amacı\nBu projenin amacı yapılandırılmış metin (Structured Text - ST) kullanarak sonlu durum makinesi (Finite State Machine - FSM) yaklaşımıyla bir kavşaktaki trafik ışığı sisteminin simülasyonunun gerçekleştirilmesidir.\n\n\n2.2. Problem\nKarmaşık kontrol senaryolarında, geleneksel “Ladder” diyagramı veya basit zamanlayıcı (Timer) zincirleri kullanmak, sistem büyüdükçe şu sorunlara yol açmaktadır:\n\nYönetilebilirlik: Sisteme ait durumlar (örn: başlangıç, gündüz, gece, acil vb.) arttıkça kodun okunabilirliği azalmaktadır.\nSenkronizasyon: Zamanlayıcıların asenkron çalışması sonucu işlevlerin çakışma riski (örn: aynı anda iki yeşil ışık yanması) bulunmaktadır.\nEsneklik: Yeni bir kural eklendiğinde tüm kodun baştan yazılması gerekebilmektedir.\n\n\n\n2.3. Çözüm ve Yaklaşım\nBelirtilen problemleri aşmak adına bu sistem ST programlama ile FSM mimarisi kullanılılarak yapılmıştır.\n\nHer trafik durumu (Kırmızı, Sarı, Yeşil) izole bir CASE adımı olarak tanımlanmıştır.\nGeçişler, katı mantıksal koşullara (Transition Conditions) bağlanarak hata riski minimize edilmiştir.\nGörselleştirme katmanı (Visualization/TargetVisu), kontrolcüden bağımsız çalışacak şekilde optimize edilmiştir."
  },
  {
    "objectID": "projects/traffic-lights-codesys/index.html#sistem-mimarisi-ve-tasarım",
    "href": "projects/traffic-lights-codesys/index.html#sistem-mimarisi-ve-tasarım",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "3. Sistem Mimarisi ve Tasarım",
    "text": "3. Sistem Mimarisi ve Tasarım\nBu projede PLC programı CODESYS ortamında ST dili kullanılarak yazılmıştır. Projede tanımlanan trafik ışığı değişkenlerinin “Visualization” objesinde bulunan tasarım ekranı bileşenleriyle etkileşim kurmaları sağlanmıştır. Sistemin görsel olarak izlenebilmesi için yol ve ışık objeleri, başlatma-durdurma ve gece modu butonları oluşturulmuştur. Trafik ışıkları bulunduğu yön ve renk bilgisiyle tanımlanmıştır.\n\n3.1. Algoritma ve İşleyiş Mantığı\nSistem kontrolü, durum ve geçişlere dayalı FSM yapısı ile gerçekleştirilmiştir. Algoritma, karmaşık IF-ELSE blokları yerine, birbirinden izole edilmiş durumlar (states) üzerinden ilerlemektedir:\n\nBaşlangıç: Sistemin enerjilendiği, sistem kapanırken değişkenlerin sıfırlandığı ve güvenlik kontrollerinin yapıldığı ana döngü.\nGündüz Modu : Trafik ışıklarının önceden tanımlı sürelerde (Kırmızı, Sarı, Yeşil) sıralı olarak değiştiği döngü.\nGece Modu : Belirli bir tetikleyici ile (manuel buton veya saat) devreye giren, tüm sarı ışıkların saniyede iki kez yanıp söndüğü döngü.\n\n\n\n3.2. Teknik Yaklaşım\n\nSistemin programlanmasında dil seçimi olarak ST programlama tercih edilmiştir. Ladder diyagramı görsel olarak takip edilebilen bir yapıda olsa da durum yönetiminde yetersiz kalabilmektedir. Bu projede, kodun okunabilirliğini arttırmak hata ve durum yönetimini daha da kolaylaştırmıştır.\nSıralı akış yerine durum tabanlı yaklaşım seçilmesinin temel nedeni genişletilebilirliktir. İleride sisteme “Yaya Butonu” veya “Acil Durum Modu” gibi eklemeler yapılması gerektiğinde, mevcut kod yapısını bozmadan sadece yeni bir STATE bloğu entegre edilmesi yeterli olacaktır."
  },
  {
    "objectID": "projects/traffic-lights-codesys/index.html#uygulama-ve-kod-detayları",
    "href": "projects/traffic-lights-codesys/index.html#uygulama-ve-kod-detayları",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "4. Uygulama ve Kod Detayları",
    "text": "4. Uygulama ve Kod Detayları\nSistemin yazılım altyapısı; sürdürülebilirlik, modülerlik ve standartlara uygunluk gözetilerek geliştirilmiştir. Aşağıda, projenin temelini oluşturan veri yapıları ve işleyen kod mantığı teknik detaylarıyla sunulmuştur.\n\n4.1. Değişken ve Tanımlar\nSistemde kullanılan değişkenler ve veri tipleri, IEC 61131-3 standardı ile uyumlu ve PLCopen Task Force: Coding Guidelines tarafından tavsiye edilen Type-prefixed Hungarian Notation yaklaşımıyla tanımlanmış ve kullanım amaçlarına göre sınıflandırılmıştır.\n\n\n\n\n\n\nNotTanımlanan Değişkenler\n\n\n\n\n\nPROGRAM PLC_PRG\nVAR\n    xStart      : BOOL := FALSE;  \n    xNightMode  : BOOL := FALSE;\n    \n    iStep       : INT := 0;\n    tDuration   : TIME;            \n    \n    xKuzeyGuneyYesil    : BOOL;\n    xKuzeyGuneySari     : BOOL; \n    xKuzeyGuneyKirmizi  : BOOL; \n    xDoguBatiYesil      : BOOL;\n    xDoguBatiSari       : BOOL;\n    xDoguBatiKirmizi    : BOOL;\n\n    fbStepTimer         : TON;\n    fbBlinkTimer        : TON;                \nEND_VAR\n\n\n\n\n\n4.2. Algoritma ve Kod Mantığı\nProjenin karar mekanizması, Sonlu Durum Makinesi (FSM) mimarisi üzerine kurgulanmıştır. Bu yapı, her senaryonun birbirinden izole şekilde işletilmesini ve kodun kontrollü akışını sağlar.\n\n\n\n\n\n\nNotKod Bloğu\n\n\n\n\n\n(* Zamanlayının Döngüsel Güncellemesi *)\nfbStepTimer(IN := (xStart AND NOT xNightMode AND NOT fbStepTimer.Q), PT:= tDuration);\n\n(* Ana Döngü *)\nIF xStart THEN\n    (* Mod Yönetimi: Öncelik Gece Modundadır *)\n    IF xNightMode THEN\n        // Gece modu algoritması (Kodun bu kısmı özetlenmiştir...)\n    ELSE\n        (* Gündüz Modu - Durum Makinesi Akışı *)\n        CASE iStep OF\n            10: (* DURUM: K-G Yeşil, D-B Kırmızı *)\n                xKuzeyGuneyYesil := TRUE; \n                xDoguBatiKirmizi := TRUE;\n                tDuration := T#5S; \n                \n                // Durum Geçiş Koşulu\n                IF fbStepTimer.Q THEN iStep := 20; END_IF;\n    \n            20: (* DURUM: K-G Sarı, D-B Kırmızı *)\n                xKuzeyGuneyYesil := FALSE; \n                xKuzeyGuneySari := TRUE;\n                tDuration := T#2S; \n                \n                IF fbStepTimer.Q THEN iStep := 30; END_IF;         \n                 \n            // ... (* Akış diğer durumlar ile devam eder *) ...\n        END_CASE\n    END_IF;\nELSE\n    (* Reset / Güvenli Durum *)\n    iStep := 0;\n    xKuzeyGuneyYesil := FALSE; xKuzeyGuneySari := FALSE; xKuzeyGuneyKirmizi := FALSE;\n    xDoguBatiYesil   := FALSE; xDoguBatiSari   := FALSE; xDoguBatiKirmizi   := FALSE;\n    // Sistem kapatıldığında tüm çıkışlar güvenli konuma alınır..\nEND_IF;"
  },
  {
    "objectID": "projects/traffic-lights-codesys/index.html#karşılaşılan-teknik-zorluklar-ve-çözüm-süreçleri",
    "href": "projects/traffic-lights-codesys/index.html#karşılaşılan-teknik-zorluklar-ve-çözüm-süreçleri",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "5. Karşılaşılan Teknik Zorluklar ve Çözüm Süreçleri",
    "text": "5. Karşılaşılan Teknik Zorluklar ve Çözüm Süreçleri\nProje geliştirme aşamasında karşılaşılan teknik kısıtlar ve bu kısıtları aşmak için uygulanan mühendislik çözümleri aşağıda detaylandırılmıştır.\n\n5.1. Görsel Bileşenlerin Hizalanması\nProblem: Eklenen bileşenlerin görsel şemaya uygun bir şekilde birbirleriyle simetrik ve estetik bir görünümde olması gerekiyordu.\nÇözüm: Bileşenler sınırlı bir alan içerisine rounded-rectangle bileşeninin üzerine çizildi. Böylece Visualization ekranında bileşenlerin birbirine ve yer aldığı bölgeye göre yatay ve dikey hizalaması gerçekleştirildi. Daha sonra eklenen rounded-rectangle bileşeni görünmez yapıldı.\n\n\n\n\n\n\nGörsel 1\n\n\n\n\n\n\n\nGörsel 2\n\n\n\n\n\n\n\n5.2. Durum Verilerinin Anlık Gösterimi\nProblem: Simülasyon ekranında o anki trafik ışığı durumu güzergaha göre (Örn: “Kuzey-Güney Yeşil”) ekranda gösterilmesi gerekiyordu.\n\nÇözüm: Problemin çözümü için Text List özelliği kullanıldı. Durum değişkeni (iStep) doğrudan bir ID olarak listeye bağlandı ve sadece ilgili durumun metni dinamik olarak çağrıldı.\n\n\n\n\n\n\nStates V1\n\n\n\n\n\n\n\nStates V1\n\n\n\n\n\n\n\n\n\nDynamics Text V1\n\n\n\n\n\n\n\nDynamics Text V2"
  },
  {
    "objectID": "projects/traffic-lights-codesys/index.html#sonuç",
    "href": "projects/traffic-lights-codesys/index.html#sonuç",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "6. Sonuç",
    "text": "6. Sonuç\nBu proje kapsamında, endüstriyel otomasyon süreçlerinde önemli bir yere sahip olan FSM yapısı trafik kontrol projesi üzerinden IEC 61131-3 standartlarına uygun olarak başarıyla modellenmiştir. Bu proje ile ST programlama kullanarak FSM mantığı pekiştirilmeye çalışılmıştır. Aynı zamanda gerçekleştirilen kod blokları görsel bir sahneye dönüştürülmüş değişkenler ve görsel bileşenler arasında senaryoya uygun ilişkilendirilmeler yapılmıştır.\nProje Çıktıları:\n\nDeterministik Kontrol: FSM mimarisi sayesinde, durumlar arası geçişlerdeki belirsizlikler ve çakışma riskleri ortadan kaldırılmıştır.\nModülerlik: Kod yapısı, CASE blokları ile izole edilerek bakımı kolay ve genişletilebilir bir formata getirilmiştir.\nSanal Devreye Alma: CODESYS TargetVisu kullanılarak, fiziksel donanıma ihtiyaç duyulmadan mantıksal doğrulama sağlanmıştır."
  },
  {
    "objectID": "projects/traffic-lights-codesys/index.html#referanslar-ve-kaynakça",
    "href": "projects/traffic-lights-codesys/index.html#referanslar-ve-kaynakça",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "7. Referanslar ve Kaynakça",
    "text": "7. Referanslar ve Kaynakça\nProje sürecinde yararlanılan teknik dokümanlar ve araçlar aşağıdadır:\n\nStandart: IEC 61131-3, PLCopen Coding Guidelines\nDokümantasyon: CODESYS Online Help\nGitHub Deposu: unusual-data/codesys-traffic-lights\nDoğrudan İndir İndir (.zip)\n\n\n\n      \n        İbrahim Çapar\n        ::\n        20 Aralık 2025"
  },
  {
    "objectID": "projects/sequential-motor-control/index.html",
    "href": "projects/sequential-motor-control/index.html",
    "title": "ST Programlama ile Sıralı Motor Kontrolü",
    "section": "",
    "text": "Kategori\nDetay\n\n\n\n\nAlan\nEndüstriyel Otomasyon\n\n\nMimari & Metodoloji\nSonlu Durum Makinesi (FSM)\n\n\nTeknolojiler\nCODESYS V3.5, Structured Text (ST), TargetVisu\n\n\nUygulama Odağı\nSıralı Motor Kontrolü\n\n\nKaynak\nGitHub’da İncele & Projeyi İndir (.zip)"
  },
  {
    "objectID": "projects/sequential-motor-control/index.html#proje-künyesi",
    "href": "projects/sequential-motor-control/index.html#proje-künyesi",
    "title": "ST Programlama ile Sıralı Motor Kontrolü",
    "section": "",
    "text": "Kategori\nDetay\n\n\n\n\nAlan\nEndüstriyel Otomasyon\n\n\nMimari & Metodoloji\nSonlu Durum Makinesi (FSM)\n\n\nTeknolojiler\nCODESYS V3.5, Structured Text (ST), TargetVisu\n\n\nUygulama Odağı\nSıralı Motor Kontrolü\n\n\nKaynak\nGitHub’da İncele & Projeyi İndir (.zip)"
  },
  {
    "objectID": "projects/sequential-motor-control/index.html#genel-bakış-ve-problem-tanımı",
    "href": "projects/sequential-motor-control/index.html#genel-bakış-ve-problem-tanımı",
    "title": "ST Programlama ile Sıralı Motor Kontrolü",
    "section": "2. Genel Bakış ve Problem Tanımı",
    "text": "2. Genel Bakış ve Problem Tanımı\n\n2.1. Proje Amacı\nBu projenin amacı ST (Structured Text) programlama dili ile sonlu durum makinesi (Finite State Machine - FSM) yapısını kullanarak bir üretim hattındaki sıralı işlemlerin kontrolünün simülasyonunun gerçekleştirilmesidir.\n\n\n2.2. Problem\nBir proseste bulunan sıralı işlemlerin kontrolünde “Ladder” diyagramı veya her çıkışın bir sonrakini aktif ettiği geleneksel yaklaşım şu sorunlara yol açmaktadır:\n\nYönetilebilirlik: Prosese ait işlemlerde yapılmak istenilen ekleme veya değişim işlemi kod karmaşasını arttırmaktadır.\nEsneklik: Yeni bir kural eklendiğinde kodda çok fazla değişiklik gerekebilmektedir.\n\n\n\n2.3. Çözüm ve Yaklaşım\nBelirtilen problemleri çözmek için FSM yapısı kullanılmıştır.\n\nHer bir motorun sıralı çalışması ve durması için her bir aşama CASE yapısında bir durum olarak tanımlanmıştır.\nHerhangi bir motorun arızaya geçmesi durumunda bütün proses güvenli bir şekilde durdurulmaktadır. Hata resetleme işlemi yapıldıktan sonra sistem kaldığı yerden çalışacak şekilde programlanmıştır."
  },
  {
    "objectID": "projects/sequential-motor-control/index.html#sistem-mimarisi-ve-tasarım",
    "href": "projects/sequential-motor-control/index.html#sistem-mimarisi-ve-tasarım",
    "title": "ST Programlama ile Sıralı Motor Kontrolü",
    "section": "3. Sistem Mimarisi ve Tasarım",
    "text": "3. Sistem Mimarisi ve Tasarım\nBu projede PLC programlama için CODESYS ortamı tercih edilmiştir. Proje ST programlama dili kullanılarak kodlanmıştır. Sıralı motor kontrolü görselleştirilerek “Visualization” objesinde, hazırlanan senaryoya uygun tasarım yapılmıştır. Simülasyonun sağlıklı bir şekilde gerçekleşmesi için ekranda başlat, durdur, reset butonları oluşturulmuştur. Motorlarda oluşabilecek hatayı simüle etmek için ekranda Arıza Simülasyon Paneli tasarlanmıştır. Bu panelde DIP-SWITCH objeleri her bir motora ait hata sinyalini temsil etmektedir. Bu objelerin altında bulunan lamba ise, sistem arızaya geçtiğinde yanması gereken arıza ikaz uyarı ışığını temsil etmektedir.\n\n3.1. Algoritma ve İşleyiş Mantığı\nSistem işleyişi Durum Makinesi içerisinde yönetilmiştir. Start butonuna basıldığında ilk motor çalışmaya başlamaktadır. Birinci motor çalıştıktan sonra, ikinci motor çalışmaktadır. İkinci motor çalıştıktan sonra da üçüncü motor çalışmaya başlamaktadır. Motorlar 5 saniye aralıklarla çalışmaya başlamaktadır. Stop butonuna basıldığında ise önce üçüncü motor, sonra ikinci motor, en sonda birinci motor durmaktadır. Motorlar 3 saniye aralıklarla durma işlemini gerçekleştirmektedir.\nMotorlardan herhangi birisi arızalanırsa sistem durum makinesi içerisindeki arıza durumuna geçmektedir. Sistem resetlenmeden tekrar çalışmaya başlamamaktadır.\n\n\n3.2. Teknik Yaklaşım\n\nSıralı motor kontrol sistemi CODESYS ortamında ST programlama dili ile programlanmıştır. Kullanılan algoritma yapısı Sonlu Durum Makinesi’dir.\nSonlu durum makinesi ile prosesin başlatılması ve durdurulması güvenli ve stabil bir yapıda yönetilmiştir. İleride yapılacak eklemelerde ana yapı korunarak genişletme yapabilmek mümkün olacaktır."
  },
  {
    "objectID": "projects/sequential-motor-control/index.html#uygulama-ve-kod-detayları",
    "href": "projects/sequential-motor-control/index.html#uygulama-ve-kod-detayları",
    "title": "ST Programlama ile Sıralı Motor Kontrolü",
    "section": "4. Uygulama ve Kod Detayları",
    "text": "4. Uygulama ve Kod Detayları\nProjede uygulanan algoritma uluslararası standart ve yaklaşımlar gözetilerek kodlanmıştır. Durum makinesi yaklaşımıyla prosese ait bütün aşamalar modüler bir şekilde yönetilebilmektedir. Değişkenler PLCopen Task Force: Coding Guidelines standardında belirtilen Type-prefixed Hungarian Notation yönergesine göre atanmıştır.\n\n4.1. Değişken ve Tanımlar\nProje simülasyon ortamında geliştirildiği için değişkenler için INPUT ve OUTPUT kapsamı ön ek ile belirtilmemiştir.\n\n\n\n\n\n\nNotDeğişkenler\n\n\n\n\n\nPROGRAM PLC_PRG\nVAR_INPUT\n    xStart           : BOOL;\n    xStop            : BOOL;\n    xReset           : BOOL;\n    \n    xFault_M1        : BOOL; \n    xFault_M2        : BOOL;\n    xFault_M3        : BOOL;\nEND_VAR\n\nVAR_OUTPUT\n    xM1Coil          : BOOL;\n    xM2Coil          : BOOL;\n    xM3Coil          : BOOL;\n    xLampFault       : BOOL;\nEND_VAR\n\nVAR\n    iState          : INT := 0;   \n    fbTimeDuration  : TON;       \n    xTimerStart     : BOOL;       \n    tPeriod         : TIME;     \n    \n    tStartWaiting   : TIME := T#5S;\n    tStopWaiting    : TIME := T#3S;\n    tRemainingTime  : TIME;\n    \n    fbTrigStart     : R_TRIG;\n    fbTrigStop      : R_TRIG;\n    fbTrigReset     : R_TRIG;\nEND_VAR\n\n\n\n\n\n4.2. Algoritma ve Kod Mantığı\nProjede kullanılan START, STOP, RESET butonu her döngüde bir kere okunabilmesi için R_TRIG fonksiyon blokları tanımlanmış ve bunlar da kodun en başında ilgili butonlara ataması yapılmıştır. Herhangi bir arıza durumunda sistem arıza durumuna (iState : 99) geçmektedir. Motor ve lambaya ait çıkışların sadece ilgili durumlarda çalışması istendiği için lojik olarak 23 ile 26. satırlar arasında gösterilen kodlar eklenmiştir.\n\n\n\n\n\n\nNotKod Bloğu\n\n\n\n\n\nfbTrigStart(CLK := xStart);\nfbTrigStop(CLK := xStop);\nfbTrigReset(CLK := xReset);\n\n//(*&lt;-----------------------------------------------&gt;*)\n\nIF xFault_M1 OR xFault_M2 OR xFault_M3 THEN\n    iState := 99;\nEND_IF\n\n//(*&lt;-----------------------------------------------&gt;*)\n\n    10:\n        tPeriod := T#5S;\n        xTimerStart := TRUE;\n        IF fbTimeDuration.Q THEN\n            xTimerStart := FALSE;\n            iState := 20;\n        END_IF\n\n//(*&lt;-----------------------------------------------&gt;*)\n\nxM1Coil := (iState &gt;= 10) AND (iState &lt;= 50);\nxM2Coil := (iState &gt;= 20) AND (iState &lt;= 40);\nxM3Coil := (iState = 30);\nxLampFault := (iState = 99);"
  },
  {
    "objectID": "projects/sequential-motor-control/index.html#karşılaşılan-teknik-zorluklar-ve-çözüm-süreçleri",
    "href": "projects/sequential-motor-control/index.html#karşılaşılan-teknik-zorluklar-ve-çözüm-süreçleri",
    "title": "ST Programlama ile Sıralı Motor Kontrolü",
    "section": "5. Karşılaşılan Teknik Zorluklar ve Çözüm Süreçleri",
    "text": "5. Karşılaşılan Teknik Zorluklar ve Çözüm Süreçleri\n\n5.1. Zaman Yönetimi\nProblem: Sıralı çalışma sırasında başlatma ve durdurma işlemi yaparken belirlenen sürenin geçmesi gerekmektedir. Bu süre dolmadan bir sonraki aşama başlamamalı veya durmamalıdır.\nÇözüm: xTimerStart isminde boolean veri tipinde sanal bir değişken (bayrak) tanımlanmıştır. Bu değişken geçen süreyi hesaplamak için kullanılan TON veri tipindeki zamanlayıcının Input girişine atanmıştır. Her bir durum içerisinde önce bu değişkene TRUE değeri yazılmakta ve zaman çıkışı elde edildikten sonra tekrar değeri FALSE yapılmaktadır. Başlangıç ve arıza durumunda (0 ile 99) herhangi bir süre işlemi gerçekleşmemesi için değeri FALSE olarak sabit tutulmaktadır.\n\n\n5.2. Beklenilmeyen Kesinti ve Hata Durumları\nProblem: Programın çalışması sırasında bir enerji kesintisi veya herhangi bir hata ile program kesintiye uğrama ihtimali bulunmaktadır.\nÇözüm: Sistemin sıralı bir şekilde çalışması gerekmektedir. Durumlar arası geçişi iState değişkeni ile durum makinesi sağlamaktadır. Ancak herhangi bir kesinti ve hata durumunda programın tekrar kaldığı yerden sorunsuz şekilde çalışması için case yapısının dışarısına lojik doğrulama eklenmiştir. Böylece motor çıkışları ve arıza ikaz lambası sadece bu durum aralıklarında çalışmaktadır. Herhangi bir hata ve kesintiden etkilenmemektedir."
  },
  {
    "objectID": "projects/sequential-motor-control/index.html#sonuç",
    "href": "projects/sequential-motor-control/index.html#sonuç",
    "title": "ST Programlama ile Sıralı Motor Kontrolü",
    "section": "6. Sonuç",
    "text": "6. Sonuç\nBu projede endüstriyel otomasyon sistemlerinde bulunan sıralı işlem yapısı durum makinesi yöntemiyle programlanmıştır. Bununla birlikte gerçekleştirilen senaryonun takibini ve canlandırmasını kolaylaştırmak için simülasyon ortamında senaryoya uygun tasarım yapılmıştır.\nProje Çıktıları:\n\nTemiz Kod: Durum makinesi yöntemi sayesinde durumlar arası sıralı geçişler sistematik bir şekilde yönetilmiştir. Hata durumu, motor çıkışları ve zaman yönetimi bu yaklaşıma göre hazırlanmıştır.\nModülerlik: Kod yapısı durum makinesi içerisinde gelecekte yapılacak değişikliklere karşı kolayca yönetilebilecek şekilde programlanmıştır.\nSimülasyon: CODESYS platformunda bulunan TargetVisu objesi kullanılarak HMI tasarımı mantığıyla simülasyon sahnesi hazırlanmıştır."
  },
  {
    "objectID": "projects/sequential-motor-control/index.html#referanslar-ve-kaynakça",
    "href": "projects/sequential-motor-control/index.html#referanslar-ve-kaynakça",
    "title": "ST Programlama ile Sıralı Motor Kontrolü",
    "section": "7. Referanslar ve Kaynakça",
    "text": "7. Referanslar ve Kaynakça\n\nStandart: IEC 61131-3, PLCopen Coding Guidelines\nDokümantasyon: CODESYS Online Help\nGitHub Deposu: unusual-data/sequential-motor-control\nDoğrudan İndir İndir (.zip)\n\n\n\n      \n        İbrahim Çapar\n        ::\n        12 Ocak 2026"
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Blog Yazılarım",
    "section": "",
    "text": "Sıralama Öğesi\n      Varsayılan\n      \n        Başlık\n      \n      \n        Tarih - En eski\n      \n      \n        Tarih - En yeni\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nTIA Portal ve Factory I/O ile Python: Sanal Ayıklama Uygulaması\n\n\nPython Programlama ile Sanal Ayıklama Uygulaması\n\n\nPython programlama kullanarak Factory I/O ve TIA Portal haberleşmesiyle Factory I/O ortamında konveyörde bulunan hammaddeleri renklerine göre ayırma uygulaması.\n\n\n\n\n\n13 Aralık 2025\n\n\n\n\n\n\n\n\n\n\n\n\nVisual Components #1: Layout Konfigürasyonu\n\n\nVisual Components\n\n\nVisual Components Academy platformunda bulunan “Introduction to Layout Configuration” dersinin uygulaması.\n\n\n\n\n\n11 Aralık 2025\n\n\n\n\n\nEşleşen öğe yok"
  },
  {
    "objectID": "posts/sanal-ayiklama/index.html",
    "href": "posts/sanal-ayiklama/index.html",
    "title": "TIA Portal ve Factory I/O ile Python: Sanal Ayıklama Uygulaması",
    "section": "",
    "text": "İpucuKullanılan Yazılımlar\n\n\n\nTIA Portal V20, PLCSIM V20, Factory I/O, Spyder IDE, NetToPLCsim"
  },
  {
    "objectID": "posts/sanal-ayiklama/index.html#işlem-adımları",
    "href": "posts/sanal-ayiklama/index.html#işlem-adımları",
    "title": "TIA Portal ve Factory I/O ile Python: Sanal Ayıklama Uygulaması",
    "section": "İşlem Adımları",
    "text": "İşlem Adımları\n\n1. Factory I/O TIA Portal Template İndirme\nBu projede gerçekleştirilen senaryoda TIA Portal V20 ile PLCSIM üzerinden Factory I/O haberleşmektedir. Bu işlemin gerçekleşebilmesi için Factory I/O template dosyası gerekmektedir. Bunun için Factory I/O Template adresinden ilgili dosya edinilmiştir.\n\n\n\n\n\n\nDikkatUyarı\n\n\n\nGerçekleştirilen senaryoda TIA Portal V20 ile PLCSIM V20 kullanıldığı için\n“FactoryIO_Template_S7-1200_V20.zip” dosyası indirilmiştir. Farklı bir sürüm kullanılması durumunda\nkullanılan sürüme uygun template dosyasını edinilmelidir.\n\n\n\n\n2. Factory I/O Template ile TIA Portal Programı Oluşturma\nİndirilen bu template dosyası TIA Portal ile birlikte açılarak kullanılmıştır.\n\n\nTemplate dosyası ayrıca TIA Portal arayüzü üzerinden “Open Project” menüsünden de açılabilmektedir.\n\nTemplate dosyası TIA Portal arayüzünde açıldıktan sonra uygulanmak istenen senaryoya yönelik program hazırlanmıştır.\nAşağıdaki resimlerde belirtilen senaryoya yönelik LD (Ladder Diagram) programı gösterilmektedir.\n\n\n\n\n\n\nUyarıPUT/GET İzni\n\n\n\nBu aşamada aşağıdaki PUT/GET izni verilmelidir.\n“TIA Portal &gt; Device Configuration &gt; General &gt; Connection mechanisms &gt; Permit access with PUT/GET communication from remote partner” kutucuğu işaretlenerek izin verilebilmektedir.\nBu ayar yapıldıktan sonra PLC’ye sağ tıklayarak Compile &gt; Hardware (rebuild all) seçeneği ile rebuild işlemi gerçekleştirilip proje PLCSIM’e (Download to device) seçeneği ile yüklenilmelidir.\n\n\n\n\n\n\n\n\nDikkatUyarı\n\n\n\nFactory I/O template dosyası TIA Portal ile açıldığında varsayılan program bloğu dili FB olarak gelmektedir. Main [OB1] &gt; Switch Programming Language &gt; LAD işlem adımlarını uygulayarak ladder diyagramı ile program yazılabilmektedir.\n\n\n\n\n\nLadder - 1\n\n\n\n\n\nLadder - 2\n\n\n\n\n\nLadder - 3\n\n\n\n\n3. PLCSIM - TIA Portal Haberleşmesi\nHazırlanan senaryoya uygun kod hazırlandıktan sonra derleme işlemi gerçekleştirilmiştir. Bu işlem adımı için “Edit &gt; Compile” veya “Ctrl + B” kısayolu kullanılabilmektedir. Devamında üst menüde bulunan “Start Simülation” butonu ile PLCSIM’ başlatılmıştır.\nAçılan ekranda “Start Search” yaparak bağlı olunan cihazlar listelenmektedir. Bu işlemi yaparken “PG/PC Interface : PLCSIM” seçeneğinin belirtildiği gibi olması gerekmektedir. Arama sonucunda PLCSIM PLC seçilerek program “Load” denilerek yüklenmiştir.\n\nDevamında açılır listeden “Start Module” seçeneği seçilerek “Finish” butonuna basılarak işlem tamamlanmıştır.\n\nBöylelikle TIA Portal ile PLCSIM haberleşmesi gerçekleştirilmiştir.\n\nPLCSIM &gt; SimView menüsünden manuel olarak eklediğiniz girişleri değiştirerek çıkışın nasıl etkilendiğini gözlemleyebilirsiniz.\n\n\n\n4. NetToPLCSim Ayarları\nGerçekleştireceğimiz senaryoda görüntü işleme ile ilgili işlemler için “Python” kullanılacaktır. Python-TIA Portal haberleşmesini sağlamak için “NetToPLCSim” programı kullanılmıştır.\nProgram indirme bağlantısı: NetToPLCSim\nProgramı indirdikten sonra “Add” ile ekleme yapılır.\n\nGelen ekranda;\n\n1 Numara: Eklenecek bağlantıya istenilen isim verilebilmektedir.\n2 Numara: Network IP Adress’in en sağında bulunan “…” sembolüne tıklayarak kulllandığınız bilgisayara ait IP adresinin eklenmesi gerekmektedir.\n3 Numara: PLCSim IP Adress’in en sağında bulunan “…” sembolüne tıklayarak PLCSIM’in IP adresinin eklenmesi gerekmektedir.\n4 Numara: Burada belirtilen “2” sayısı “1” ile değiştirilmelidir. Siemens S7-1200 PLC için Rack / Slot numarası: 0 / 1 şeklinde olmalıdır.\n\nBağlantılar doğru gerçekleştirildiğinde “…” sembolüne tıklandığında IP adresleri ekranda listelenmektedir.\n\nBelirtilen ayarlar yapıldıktan sonra ekran aşağıdaki gibi gözükmektedir. “Start Server” diyerek bağlantı başlatılmıştır.\n\nStatus alanının “RUNNING” olduğu görülerek bir sonraki aşamaya geçilmiştir.\n\n\n5. Factory I/O Sahnesi Oluşturma\nSürecin devamında Factory I/O ile hazırlanan senaryoya uygun sahne oluşturulmuştur. Hazırlanan senaryoya uygun bileşenler (emitter, belt conveyor, curved conveyor, pusher, electric switchboard, emergency stop, stop button, start button) sahneye uygun konumda yerleştirilmiştir.\n\n\nBileşenlerin dikey eksende (yukarı/aşağı) konumlandırılması için ‘V’ kısayol tuşu kullanılmaktadır.\n\n\n\n6. Factory I/O Konfigürasyon\nFactory I/O uygulamasında üst menüden “File&gt;Drivers” menüsüne giderek sol üstte”DRIVER”ın hizasında yanında bulunan açılır listeden “Siemens S7-PLCSIM” seçilmiştir. Bu aşamada TIA Portal-PLCSIM üzerinden Factory I/O ile haberleşmesi tamamlanmıştır.\n\nPLC kodunda tanımlanan değişkenler, “File &gt; Drivers” menüsü üzerinden ilgili fiziksel giriş ve çıkış adresleri ile eşleştirilmiştir.\n\nBu işlem gerçekleştirildikten sonra sağ üstte bulunan “Connect” tuşuna basılarak TIA Portal’da hazırlanan kod PLCSIM aracılığıyla Factory I/O ile haberleştirilmiştir.\n\nPLCSIM aracılığı ile bağlanılan PLC “Run” modunda olmalıdır\n\nFactory I/O ortamında konveyörde hareket eden mavi ve yeşil hammaddeleri algılayarak işlem yapabilmek için Python programlama dili kullanılmıştır.\n\n\n\n\n\n\nİpucuKullanılan Kütüphaneler\n\n\n\ntime,cv2,numpy,mss,snap7\n\n\nBu adımla birlikte Factory I/O ve TIA Portal (PLCSIM) arasındaki simülasyon bağlantısı tamamlanmıştır. Artık senaryodaki görüntü işleme mantığını uygulamak üzere Python kodlama aşamasına geçilmiştir.\n\n\n7. Python Programlama Adımları\n\n\n7.1. Kullanılan Kütüphanelerin “Import” edilmesi\nİlk olarak hazırlanan senaryonun çalıştırılabilmesi için gereken kodları barındıran kütüphaneler “Import” edilmiştir.\ntime kütüphanesi : Programda bulunan döngü zamanlamasını yönetmek için kullanılmıştır.\ncv2 kütüphanesi : Görüntüyü HSV’ye çevirme, renk aralığına göre maske üretme, maskede piksel sayma vb. işlemlerini gerçekleştirmek için kullanılmışır.\nnumpy kütüphanesi : “mss” ile yakalanan ekran görüntüsünü diziye (np.array) çevirme, HSV eşik değerlerini dizi olarak tanımlama ve görüntü üzerinde dilimleme yapmak için kullanılmıştır\nmss kütüphanesi : Factory I/O ortamında kamera bulunmadığı için ekranda belirlenen bölgelerin (ROI) yakalanmasını sağlamak için kullanılmıştır.\nsnap7 kütüphanesi : Siemens S7-1200 PLC ile Python üzerinden bağlanıp veri alışverişi yapmak için kullanılmıştır.\nsnap7.util : PLC byte’ı içindeki ilgili biti set etmek için kullanılmıştır.\n\n\n\n\n\n\nNotImport Etme\n\n\n\n\n\nimport time\nimport cv2\nimport numpy as np\nimport mss\nimport snap7\nfrom snap7 import util\n\n\n\n\n\n7.2. Sistem Konfigürasyonu\nProgramda kullanılacak kütüphaneler eklendikten sonra bu aşamada program içerisinde kullanacağımız değişkenlerin tanımlaması yapılmıştır. Konfigürasyon tamamlandıktan sonra “plc.connect()” komutuyla bağlantı sağlanmıştır.\n\n\n\n\n\n\nNotKonfigürasyon ve Başlatma\n\n\n\n\n\n\nPLC_IP = \"XXX.XXX.XXX.XXX\"\nRACK = 0\nSLOT = 1\n\nblue_low   = np.array([75,  30, 20])\nblue_hıgh  = np.array([140, 255, 255])\n\ngreen_low  = np.array([40,  80, 50])\ngreen_hıgh = np.array([80,  255, 255])\n\nroı_blue = {'top': 432, 'left': 692, 'width': 48, 'height': 44}\nroı_green = {'top': 565, 'left': 1253, 'width': 50, 'height': 68}\n\npx_threshold = 1200\ngecen_sure = 0.10\nlast_log = 0  \nshow_debug = True\n\nplc = snap7.client.Client()\nplc.connect(PLC_IP, RACK, SLOT)\n\n\n\n\n\n7.3. Algılama ve Karar Üretme\nBu aşamada ekrandan alınan ROI görüntülerinde HSV tabanlı renk analizi yapılarak mavi ve yeşil nesnelerin varlığına karar veren görüntü işleme aşaması yönetilmiştir.\n\n\n\n\n\n\nNotAlgılama ve Sınıflandırma Aşaması\n\n\n\n\n\nwith mss.mss() as sct:\n    while True:\n        t0 = time.perf_counter()\n\n        img_b = np.array(sct.grab(roı_blue))[:, :, :3]\n        img_g = np.array(sct.grab(roı_green))[:, :, :3]\n\n        hsv_b = cv2.cvtColor(img_b, cv2.COLOR_BGR2HSV)\n        hsv_g = cv2.cvtColor(img_g, cv2.COLOR_BGR2HSV)\n\n        blue_mask  = cv2.inRange(hsv_b, blue_low, blue_hıgh)\n        green_mask = cv2.inRange(hsv_g, green_low, green_hıgh)\n\n        blue_px  = cv2.countNonZero(blue_mask)\n        green_px = cv2.countNonZero(green_mask)\n\n        blue  = blue_px  &gt; px_threshold\n        green = green_px &gt; px_threshold\n\n\n\n\n\n7.4. PLC Bit Güncelleme\nBu kod bloğunda ilk önce hedef bitin bulunduğu “Byte” PLC’den okunmuş, ilgili bit manipüle edildikten sonra tekrar yazılarak aynı adresteki diğer bitlerin korunması sağlanmıştır. Snap7 kütüphanesi ve S7 protokolü verileri Byte (8-bit) tabanlı işler. Doğrudan yazma işleminde hedef byte içerisindeki diğer 7 bit sıfırlanabilmektedir.\n\n\n\n\n\n\nNotPLC Bit Güncelleme\n\n\n\n\n\n        byte_blue = bytearray(plc.mb_read(50, 1))\n        util.set_bool(byte_blue, 0, 0, blue)\n        plc.mb_write(50, 1, byte_blue)\n        \n        byte_green = bytearray(plc.mb_read(51, 1))\n        util.set_bool(byte_green, 0, 0, green)\n        plc.mb_write(51, 1, byte_green)\n\n\n\n\n\n7.5. Periyodik Durum Log\nBu kod bloğu ile ana döngüden bağımsız olarak, saniyede 2 kez durum verileri (piksel sayıları ve lojik sonuçlar) konsola yazdırılmıştır.\n\n\n\n\n\n\nNotPeriyodik Durum Log\n\n\n\n\n\n        now = time.time()\n        if now - last_log &gt; 0.5:\n            print(f\"BLUE px={blue_px:5d} thr={PIXEL_THR} -&gt; {int(blue)} | GREEN px={green_px:5d} -&gt; {int(green)}\")\n            last_log = now\n\n\n\n\n\n7.6. Debug Amaçlı Görüntü Gösterimi\nBu aşamada ham görüntüler ile birlikte elde edilen maskeler ekrana yansıtılmıştır. Aynı zamanda klavyeden “q” harfine basınca programın manuel olarak sonlandırılabilmesi sağlanmıştır.\n\n\n\n\n\n\nNotDebug Amaçlı Görüntü Gösterimi\n\n\n\n\n\n        if show_debug:\n            cv2.imshow(\"ROI BLUE\", img_b)\n            cv2.imshow(\"BLUE MASK\", blue_mask)\n            cv2.imshow(\"ROI GREEN\", img_g)\n            cv2.imshow(\"GREEN MASK\", green_mask)\n            if cv2.waitKey(1) & 0xFF == ord('q'):\n                break\n\n\n\n\n\n7.7. Döngü Zamanlama Kontrolü\nBu kısımda düzenli veri akışı sağlamak adına, her işlem sonunda hesaplanan süre kadar bekleme uygulanmıştır.\n\n\n\n\n\n\nNotDöngü Zamanlama Kontrolü\n\n\n\n\n\n        dt = time.perf_counter() - t0\n        if dt &lt; gecen_sure: time.sleep(gecen_sure - dt)\n\n\n\n\n\n7.8. Uygulama Sonlandırma Aşaması\nProgramın en sonunda uygulama kapatılırken tüm açık pencereler ve PLC bağlantısı güvenli bir şekilde kapatılarak kaynaklar serbest bırakılmıştır.\n\n\n\n\n\n\nNotUygulama Sonlandırma Aşaması\n\n\n\n\n\ncv2.destroyAllWindows()\nplc.disconnect()\n\n\n\n\n\n\n8. Python Programı\n\n\n\n\n\n\nNotPython Kodunun Tamamını Görüntülemek için Tıklayınız\n\n\n\n\n\nimport time\nimport cv2\nimport numpy as np\nimport mss\nimport snap7\nfrom snap7 import util\n\nPLC_IP = \"XXX.XXX.XXX.XXX\"\nRACK = 0\nSLOT = 1\n\nblue_low   = np.array([75,  30, 20])\nblue_hıgh  = np.array([140, 255, 255])\n\ngreen_low  = np.array([40,  80, 50])\ngreen_hıgh = np.array([80,  255, 255])\n\nroı_blue = {'top': 432, 'left': 692, 'width': 48, 'height': 44}\nroı_green = {'top': 565, 'left': 1253, 'width': 50, 'height': 68}\n\npx_threshold = 1200\ngecen_sure = 0.10\nlast_log = 0  \n\nshow_debug = True\n\nplc = snap7.client.Client()\nplc.connect(PLC_IP, RACK, SLOT)\n\n\nwith mss.mss() as scr:\n    while True:\n        t0 = time.perf_counter()\n\n        img_b = np.array(scr.grab(roı_blue))[:, :, :3]\n        img_g = np.array(scr.grab(roı_green))[:, :, :3]\n\n        hsv_b = cv2.cvtColor(img_b, cv2.COLOR_BGR2HSV)\n        hsv_g = cv2.cvtColor(img_g, cv2.COLOR_BGR2HSV)\n\n        blue_mask  = cv2.inRange(hsv_b, blue_low, blue_hıgh)\n        green_mask = cv2.inRange(hsv_g, green_low, green_hıgh)\n\n        blue_px  = cv2.countNonZero(blue_mask)\n        green_px = cv2.countNonZero(green_mask)\n\n        blue  = blue_px  &gt; px_threshold\n        green = green_px &gt; px_threshold\n        \n        byte_blue = bytearray(plc.mb_read(50, 1))\n        util.set_bool(byte_blue, 0, 0, blue)\n        plc.mb_write(50, 1, byte_blue)\n        \n        byte_green = bytearray(plc.mb_read(51, 1))\n        util.set_bool(byte_green, 0, 0, green)\n        plc.mb_write(51, 1, byte_green)\n\n        now = time.time()\n        if now - last_log &gt; 0.5:\n            print(f\"MAVİ px={blue_px:5d} eşik={px_threshold} -&gt; {int(blue)} | YEŞİL px={green_px:5d} -&gt; {int(green)}\")\n            last_log = now\n\n        if show_debug:\n            cv2.imshow(\"Mavi ROI\", img_b)\n            cv2.imshow(\"Mavi Maskleme\", blue_mask)\n            cv2.imshow(\"Yeşil ROI\", img_g)\n            cv2.imshow(\"Yeşil Maskeleme\", green_mask)\n            if cv2.waitKey(1) & 0xFF == ord('q'):\n                break\n\n        dt = time.perf_counter() - t0\n        if dt &lt; gecen_sure: time.sleep(gecen_sure - dt)\n\ncv2.destroyAllWindows()\nplc.disconnect()\n\n\n\n\n\n9. Sonuçlar\nGerçekleştirilen projeye dair yapılan çalışmanın video kayıtları aşağıdaki gibidir.\nFactory I/O ortamında yazılan PLC programının konveyör, start, stop, acil stop butonlarının çalışması aşağıda gösterildiği gibi kontrol edilmiştir.\n\nGerçekleştirilen projenin simülasyonuna ait video kaydı aşağıdaki gibidir.\n\n\n\n      \n        İbrahim Çapar\n        ::\n        13 Aralık 2025"
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html",
    "href": "notes/references/digital-twin/vc-tips.html",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "Bu teknik referans, Visual Components simülasyon ortamında iş akışını hızlandıran klavye kısayollarını, menü ve görünüm ipuçlarını içerir.\n\n\n3D uzayda hızlı hareket etmek için standart kontroller:\n\n\n\n\n\n\n\n\n\n\n\nİşlem\nKısayol / Aksiyon\nAçıklama\n\n\n\n\nHepsini Gör\nCtrl + F\nTüm robotları ve parçaları ekrana sığdırır.\n\n\nZoom\nShift + Sağ Tık\nDoğrusal (Linear) yakınlaşma ve uzaklaşma sağlar.\n\n\nOdaklanma\nSağ Tık &gt; Center in 3D View\nSeçili nesneyi merkeze alır ve kamerayı ona odaklar.\n\n\n\n\n\nTablo 1\n\n\n\n\n\n\n\n\n\n\n\n\nİpucuİpucu: Erişim Uzayı (Workspace)\n\n\n\nRobotun erişebileceği maksimum alanı görmek için; Robot seçiliyken sağ panelden Workspace &gt; Envelope seçeneğini aktif edin.\n\n\n\n\n\n\n\n\nŞekil 1: Robot’un Çalışma Zarfı\n\n\n\n\nSnap (Yakama): Parçaları birbirine tam hizalamak için Shift tuşuna basılı tutarak sürükleyin.\n\n\n\n\n\n\n\n\n\n\nUyarıGörünüm Hatası\n\n\n\nEğer 3D ekran donarsa veya nesneler kaybolursa, View sekmesinden Reset Layout butonuna basarak görünümü sıfırlayabilirsiniz.\n\n\n\n\n\nEkranda sol alt menüde bulunan Cell Graph görünümü açılarak sahnenizdeki bileşenleri listeleyebilirsiniz. Bu listelenen bileşenlerden herhangi birine çift tıkladığınızda o bileşen seçilmiş olacaktır.\n\n\n\n\n\n\nŞekil 2: Cell Graph\n\n\n\n\n\n\nRobot Floor Track seçili iken sağ menüde Component Properties menüsünden StrokeX value değeri varsayılan olarak 5000 gelmektedir. Eğer 5000`den 7500 yapılırsa X ekseninde boyu uzamaktadır.\n\n\n\n\n\n\n\n\n\n\n\n(a) Cell Graph\n\n\n\n\n\n\n\n\n\n\n\n(b) StrokeX Düzenlemesi\n\n\n\n\n\n\n\nŞekil 3\n\n\n\nRobot Floor Track &gt; Component Properties &gt; MountOrientation değeri ile robotun, Robot Floor Track ile yaptığı açı belirlenir. Örneğin -90 yapılarak Articulated Robot , Robot Floor Track ile paralel konumlandırılmıştır.\n\n\n\n\n\n\n\n\n\n\n\n(a) MountOrientation\n\n\n\n\n\n\n\n\n\n\n\n(b) Robot\n\n\n\n\n\n\n\nŞekil 4\n\n\n\n\n\n\nKonveyör seçili iken Component Properties menüsünden ConveyorLength , ConveyorWidth , ConveyorHeight , ConveyorSpeed ayarları ile konveyöre ait uzunluk, genişlik, yükseklik ve hız değerlerini değiştirebilirsiniz.\n\n\n\n\n\n\nŞekil 5: Konveyör Özellikleri\n\n\n\n\n\n\nEklediğiniz herhangi bir Fence tıklayarak StandHeight ile fencin yerden ne kadar yükseklikte durması gerektiğini belirleyebilirsiniz.\n\n\n\n\n\n\nŞekil 6: Fence Yüksekliği\n\n\n\n\n\n\nBir bileşene sağ tıklayıp Component Properties menüsü üzerinden malzemenin materyalini ve diğer özelliklerini değiştirebilirsiniz. Örneğin Masa bileşenine sağ tıklayarak Material , Depth , Height , Length , Rotation seçenekleri ile masanın özellikleri değiştirilebilmektedir.\n\n\n\n\n\n\nŞekil 7: Masa Özellikleri\n\n\n\n\n\n\nWarehouse Shelf bileşeni için tiers bu rafın kaç sıraya sahip olacağını, bays ise kaç sütuna sahip olacağını belirtmektedir.\n\n\n\n\n\n\nŞekil 8: Warehouse Shelf Tiers & Bays\n\n\n\nWarehouse Shelf bileşeni için Options menüsünden Shelf ile raflar aktif edilmektedir. TopShelf özelliği ile en üste de raf konulabilmektedir.\n\n\n\n\n\n\nŞekil 9: Shelf & TopShelf\n\n\n\nFeeder Process tarafından raflara otomatik olarak ürün eklenmektedir. Bu ürün raflardan alınırken, rafın arkasına geçmeden alınabilmesi için bu ayar yapılmaktadır.\nWarehouse Shelf &gt; Component Properties &gt; FlowOutResourceLocation&gt; Ty&gt; Ty 1000’den &gt; -1000 Warehouse Shelf &gt; Component Properties &gt; FlowOutResourceLocation&gt; Rz&gt; Rz -90’dan &gt; 90\n\n\n\n\n\n\nŞekil 10: FlowOutResourceLocation\n\n\n\n\n\n      \n        İbrahim Çapar\n        ::\n        27.12.2025"
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#navigasyon-kısayolları",
    "href": "notes/references/digital-twin/vc-tips.html#navigasyon-kısayolları",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "3D uzayda hızlı hareket etmek için standart kontroller:\n\n\n\n\n\n\n\n\n\n\n\nİşlem\nKısayol / Aksiyon\nAçıklama\n\n\n\n\nHepsini Gör\nCtrl + F\nTüm robotları ve parçaları ekrana sığdırır.\n\n\nZoom\nShift + Sağ Tık\nDoğrusal (Linear) yakınlaşma ve uzaklaşma sağlar.\n\n\nOdaklanma\nSağ Tık &gt; Center in 3D View\nSeçili nesneyi merkeze alır ve kamerayı ona odaklar.\n\n\n\n\n\nTablo 1"
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#nesne-ve-robot-kontrolü",
    "href": "notes/references/digital-twin/vc-tips.html#nesne-ve-robot-kontrolü",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "İpucuİpucu: Erişim Uzayı (Workspace)\n\n\n\nRobotun erişebileceği maksimum alanı görmek için; Robot seçiliyken sağ panelden Workspace &gt; Envelope seçeneğini aktif edin.\n\n\n\n\n\n\n\n\nŞekil 1: Robot’un Çalışma Zarfı\n\n\n\n\nSnap (Yakama): Parçaları birbirine tam hizalamak için Shift tuşuna basılı tutarak sürükleyin."
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#menü-düzeni",
    "href": "notes/references/digital-twin/vc-tips.html#menü-düzeni",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "UyarıGörünüm Hatası\n\n\n\nEğer 3D ekran donarsa veya nesneler kaybolursa, View sekmesinden Reset Layout butonuna basarak görünümü sıfırlayabilirsiniz."
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#cell-graph",
    "href": "notes/references/digital-twin/vc-tips.html#cell-graph",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "Ekranda sol alt menüde bulunan Cell Graph görünümü açılarak sahnenizdeki bileşenleri listeleyebilirsiniz. Bu listelenen bileşenlerden herhangi birine çift tıkladığınızda o bileşen seçilmiş olacaktır.\n\n\n\n\n\n\nŞekil 2: Cell Graph"
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#robot-floor-track",
    "href": "notes/references/digital-twin/vc-tips.html#robot-floor-track",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "Robot Floor Track seçili iken sağ menüde Component Properties menüsünden StrokeX value değeri varsayılan olarak 5000 gelmektedir. Eğer 5000`den 7500 yapılırsa X ekseninde boyu uzamaktadır.\n\n\n\n\n\n\n\n\n\n\n\n(a) Cell Graph\n\n\n\n\n\n\n\n\n\n\n\n(b) StrokeX Düzenlemesi\n\n\n\n\n\n\n\nŞekil 3\n\n\n\nRobot Floor Track &gt; Component Properties &gt; MountOrientation değeri ile robotun, Robot Floor Track ile yaptığı açı belirlenir. Örneğin -90 yapılarak Articulated Robot , Robot Floor Track ile paralel konumlandırılmıştır.\n\n\n\n\n\n\n\n\n\n\n\n(a) MountOrientation\n\n\n\n\n\n\n\n\n\n\n\n(b) Robot\n\n\n\n\n\n\n\nŞekil 4"
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#konveyör",
    "href": "notes/references/digital-twin/vc-tips.html#konveyör",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "Konveyör seçili iken Component Properties menüsünden ConveyorLength , ConveyorWidth , ConveyorHeight , ConveyorSpeed ayarları ile konveyöre ait uzunluk, genişlik, yükseklik ve hız değerlerini değiştirebilirsiniz.\n\n\n\n\n\n\nŞekil 5: Konveyör Özellikleri"
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#fence",
    "href": "notes/references/digital-twin/vc-tips.html#fence",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "Eklediğiniz herhangi bir Fence tıklayarak StandHeight ile fencin yerden ne kadar yükseklikte durması gerektiğini belirleyebilirsiniz.\n\n\n\n\n\n\nŞekil 6: Fence Yüksekliği"
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#material",
    "href": "notes/references/digital-twin/vc-tips.html#material",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "Bir bileşene sağ tıklayıp Component Properties menüsü üzerinden malzemenin materyalini ve diğer özelliklerini değiştirebilirsiniz. Örneğin Masa bileşenine sağ tıklayarak Material , Depth , Height , Length , Rotation seçenekleri ile masanın özellikleri değiştirilebilmektedir.\n\n\n\n\n\n\nŞekil 7: Masa Özellikleri"
  },
  {
    "objectID": "notes/references/digital-twin/vc-tips.html#warehouse-shelf",
    "href": "notes/references/digital-twin/vc-tips.html#warehouse-shelf",
    "title": "Visual Components İpuçları",
    "section": "",
    "text": "Warehouse Shelf bileşeni için tiers bu rafın kaç sıraya sahip olacağını, bays ise kaç sütuna sahip olacağını belirtmektedir.\n\n\n\n\n\n\nŞekil 8: Warehouse Shelf Tiers & Bays\n\n\n\nWarehouse Shelf bileşeni için Options menüsünden Shelf ile raflar aktif edilmektedir. TopShelf özelliği ile en üste de raf konulabilmektedir.\n\n\n\n\n\n\nŞekil 9: Shelf & TopShelf\n\n\n\nFeeder Process tarafından raflara otomatik olarak ürün eklenmektedir. Bu ürün raflardan alınırken, rafın arkasına geçmeden alınabilmesi için bu ayar yapılmaktadır.\nWarehouse Shelf &gt; Component Properties &gt; FlowOutResourceLocation&gt; Ty&gt; Ty 1000’den &gt; -1000 Warehouse Shelf &gt; Component Properties &gt; FlowOutResourceLocation&gt; Rz&gt; Rz -90’dan &gt; 90\n\n\n\n\n\n\nŞekil 10: FlowOutResourceLocation\n\n\n\n\n\n      \n        İbrahim Çapar\n        ::\n        27.12.2025"
  },
  {
    "objectID": "notes/learning/index.html",
    "href": "notes/learning/index.html",
    "title": "Öğrenme Günlüğü",
    "section": "",
    "text": "Sürekli gelişim kapsamında öğrenilen yeni teknolojiler ve karşılaşılan günlük problemlerin teknik çözüm kayıtları.\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\nGit Deployment: Case Sensitivity 404 Hatası\n\n\n\ngit\n\ntroubleshooting\n\ncase-sensitivity\n\n\n\nWindows (Case-Insensitive) ve Linux (Case-Sensitive) dosya sistemi farkından kaynaklanan görsel yükleme hatasının isimlendirme standardı ile çözümü.\n\n\n\n2025-12-27\n\n\n2025-12-27\n\n\n\n\n\n\nEşleşen öğe yok"
  }
]