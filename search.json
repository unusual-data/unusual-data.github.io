[
  {
    "objectID": "notes/learning/index.html",
    "href": "notes/learning/index.html",
    "title": "Öğrenme Günlüğü",
    "section": "",
    "text": "Sürekli gelişim kapsamında öğrenilen yeni teknolojiler ve karşılaşılan günlük problemlerin kısa notları.\n\n\n\n\n\n\n\n\nEşleşen öğe yok"
  },
  {
    "objectID": "posts/sanal-ayiklama/index.html",
    "href": "posts/sanal-ayiklama/index.html",
    "title": "TIA Portal ve Factory I/O ile Python: Sanal Ayıklama Uygulaması",
    "section": "",
    "text": "İpucuKullanılan Yazılımlar\n\n\n\nTIA Portal V20, PLCSIM V20, Factory I/O, Spyder IDE, NetToPLCsim"
  },
  {
    "objectID": "posts/sanal-ayiklama/index.html#işlem-adımları",
    "href": "posts/sanal-ayiklama/index.html#işlem-adımları",
    "title": "TIA Portal ve Factory I/O ile Python: Sanal Ayıklama Uygulaması",
    "section": "İşlem Adımları",
    "text": "İşlem Adımları\n\n1. Factory I/O TIA Portal Template İndirme\nBu projede gerçekleştirilen senaryoda TIA Portal V20 ile PLCSIM üzerinden Factory I/O haberleşmektedir. Bu işlemin gerçekleşebilmesi için Factory I/O template dosyası gerekmektedir. Bunun için Factory I/O Template adresinden ilgili dosya edinilmiştir.\n\n\n\n\n\n\nDikkatUyarı\n\n\n\nGerçekleştirilen senaryoda TIA Portal V20 ile PLCSIM V20 kullanıldığı için\n“FactoryIO_Template_S7-1200_V20.zip” dosyası indirilmiştir. Farklı bir sürüm kullanılması durumunda\nkullanılan sürüme uygun template dosyasını edinilmelidir.\n\n\n\n\n2. Factory I/O Template ile TIA Portal Programı Oluşturma\nİndirilen bu template dosyası TIA Portal ile birlikte açılarak kullanılmıştır.\n\n\nTemplate dosyası ayrıca TIA Portal arayüzü üzerinden “Open Project” menüsünden de açılabilmektedir.\n\nTemplate dosyası TIA Portal arayüzünde açıldıktan sonra uygulanmak istenen senaryoya yönelik program hazırlanmıştır.\nAşağıdaki resimlerde belirtilen senaryoya yönelik LD (Ladder Diagram) programı gösterilmektedir.\n\n\n\n\n\n\nUyarıPUT/GET İzni\n\n\n\nBu aşamada aşağıdaki PUT/GET izni verilmelidir.\n“TIA Portal &gt; Device Configuration &gt; General &gt; Connection mechanisms &gt; Permit access with PUT/GET communication from remote partner” kutucuğu işaretlenerek izin verilebilmektedir.\nBu ayar yapıldıktan sonra PLC’ye sağ tıklayarak Compile &gt; Hardware (rebuild all) seçeneği ile rebuild işlemi gerçekleştirilip proje PLCSIM’e (Download to device) seçeneği ile yüklenilmelidir.\n\n\n\n\n\n\n\n\nDikkatUyarı\n\n\n\nFactory I/O template dosyası TIA Portal ile açıldığında varsayılan program bloğu dili FB olarak gelmektedir. Main [OB1] &gt; Switch Programming Language &gt; LAD işlem adımlarını uygulayarak ladder diyagramı ile program yazabilmektedir.\n\n\n\n\n\nLadder - 1\n\n\n\n\n\nLadder - 2\n\n\n\n\n\nLadder - 3\n\n\n\n\n3. PLCSIM - TIA Portal Haberleşmesi\nHazırlanan senaryoya uygun kod hazırlandıktan sonra derleme işlemi gerçekleştirilmiştir. Bu işlem adımı için “Edit &gt; Compile” veya “Ctrl + B” kısayolu kullanılabilmektedir. Devamında üst menüde bulunan “Start Simülation” butonu ile PLCSIM’ başlatılmıştır.\nAçılan ekranda “Start Search” yaparak bağlı olunan cihazlar listelenmektedir. Bu işlemi yaparken “PG/PC Interface : PLCSIM” seçeneğinin belirtildiği gibi olması gerekmektedir. Arama sonucunda PLCSIM PLC seçilerek program “Load” denilerek yüklenmiştir.\n\nDevamında açılır listeden “Start Module” seçeneği seçilerek “Finish” butonuna basılarak işlem tamamlanmıştır.\n\nBöylelikle TIA Portal ile PLCSIM haberleşmesi gerçekleştirilmiştir.\n\nPLCSIM &gt; SimView menüsünden manuel olarak eklediğiniz girişleri değiştirerek çıkışın nasıl etkilendiğini gözlemleyebilirsiniz.\n\n\n\n4. NetToPLCSim Ayarları\nGerçekleştireceğimiz senaryoda görüntü işleme ile ilgili işlemler için “Python” kullanılacaktır. Python-TIA Portal haberleşmesini sağlamak için “NetToPLCSim” programı kullanılmıştır.\nProgram indirme bağlantısı: NetToPLCSim\nProgramı indirdikten sonra “Add” ile ekleme yapılır.\n\nGelen ekranda;\n\n1 Numara: Eklenecek bağlantıya istenilen isim verilebilmektedir.\n2 Numara: Network IP Adress’in en sağında bulunan “…” sembolüne tıklayarak kulllandığınız bilgisayara ait IP adresinin eklenmesi gerekmektedir.\n3 Numara: PLCSim IP Adress’in en sağında bulunan “…” sembolüne tıklayarak PLCSIM’in IP adresinin eklenmesi gerekmektedir.\n4 Numara: Burada belirtilen “2” sayısı “1” ile değiştirilmelidir. Siemens S7-1200 PLC için Rack / Slot numarası: 0 / 1 şeklinde olmalıdır.\n\nBağlantılar doğru gerçekleştirildiğinde “…” sembolüne tıklandığında IP adresleri ekranda listelenmektedir.\n\nBelirtilen ayarlar yapıldıktan sonra ekran aşağıdaki gibi gözükmektedir. “Start Server” diyerek bağlantı başlatılmıştır.\n\nStatus alanının “RUNNING” olduğu görülerek bir sonraki aşamaya geçilmiştir.\n\n\n5. Factory I/O Sahnesi Oluşturma\nSürecin devamında Factory I/O ile hazırlanan senaryoya uygun sahne oluşturulmuştur. Hazırlanan senaryoya uygun bileşenler (emitter, belt conveyor, curved conveyor, pusher, electric switchboard, emergency stop, stop button, start button) sahneye uygun konumda yerleştirilmiştir.\n\n\nBileşenlerin dikey eksende (yukarı/aşağı) konumlandırılması için ‘V’ kısayol tuşu kullanılmaktadır.\n\n\n\n6. Factory I/O Konfigürasyon\nFactory I/O uygulamasında üst menüden “File&gt;Drivers” menüsüne giderek sol üstte”DRIVER”ın hizasında yanında bulunan açılır listeden “Siemens S7-PLCSIM” seçilmiştir. Bu aşamada TIA Portal-PLCSIM üzerinden Factory I/O ile haberleşmesi tamamlanmıştır.\n\nPLC kodunda tanımlanan değişkenler, “File &gt; Drivers” menüsü üzerinden ilgili fiziksel giriş ve çıkış adresleri ile eşleştirilmiştir.\n\nBu işlem gerçekleştirildikten sonra sağ üstte bulunan “Connect” tuşuna basılarak TIA Portal’da hazırlanan kod PLCSIM aracılığıyla Factory I/O ile haberleştirilmiştir.\n\nPLCSIM aracılığı ile bağlanılan PLC “Run” modunda olmalıdır\n\nFactory I/O ortamında konveyörde hareket eden mavi ve yeşil hammaddeleri algılayarak işlem yapabilmek için Python programlama dili kullanılmıştır.\n\n\n\n\n\n\nİpucuKullanılan Kütüphaneler\n\n\n\ntime,cv2,numpy,mss,snap7\n\n\nBu adımla birlikte Factory I/O ve TIA Portal (PLCSIM) arasındaki simülasyon bağlantısı tamamlanmıştır. Artık senaryodaki görüntü işleme mantığını uygulamak üzere Python kodlama aşamasına geçilmiştir.\n\n\n6. Python Programlama Adımları\n\n\n6.1 Kullanılan Kütüphanelerin “Import” edilmesi\nİlk olarak hazırlanan senaryonun çalıştırılabilmesi için gereken kodları barındıran kütüphaneler “Import” edilmiştir.\ntime kütüphanesi : Programda bulunan döngü zamanlamasını yönetmek için kullanılmıştır.\ncv2 kütüphanesi : Görüntüyü HSV’ye çevirme, renk aralığına göre maske üretme, maskede piksel sayma vb. işlemlerini gerçekleştirmek için kullanılmışır.\nnumpy kütüphanesi : “mss” ile yakalanan ekran görüntüsünü diziye (np.array) çevirme, HSV eşik değerlerini dizi olarak tanımlama ve görüntü üzerinde dilimleme yapmak için kullanılmıştır\nmss kütüphanesi : Factory I/O ortamında kamera bulunmadığı için ekranda belirlenen bölgelerin (ROI) yakalanmasını sağlamak için kullanılmıştır.\nsnap7 kütüphanesi : Siemens S7-1200 PLC ile Python üzerinden bağlanıp veri alışverişi yapmak için kullanılmıştır.\nsnap7.util : PLC byte’ı içindeki ilgili biti set etmek için kullanılmıştır.\n\n\n\n\n\n\nNotImport Etme\n\n\n\n\n\nimport time\nimport cv2\nimport numpy as np\nimport mss\nimport snap7\nfrom snap7 import util\n\n\n\n\n\n6.2 Sistem Konfigürasyonu\nProgramda kullanılacak kütüphaneler eklendikten sonra bu aşamada program içerisinde kullanacağımız değişkenlerin tanımlaması yapılmıştır. Konfigürasyon tamamlandıktan sonra “plc.connect()” komutuyla bağlantı sağlanmıştır.\n\n\n\n\n\n\nNotKonfigürasyon ve Başlatma\n\n\n\n\n\nPLC_IP = \"XXX.XXX.XXX.XXX\"\nRACK = 0\nSLOT = 1\n\nblue_low   = np.array([75,  30, 20])\nblue_hıgh  = np.array([140, 255, 255])\n\ngreen_low  = np.array([40,  80, 50])\ngreen_hıgh = np.array([80,  255, 255])\n\nroı_blue = {'top': 432, 'left': 692, 'width': 48, 'height': 44}\nroı_green = {'top': 565, 'left': 1253, 'width': 50, 'height': 68}\n\npx_threshold = 1200\ngecen_sure = 0.10\nlast_log = 0  \nshow_debug = True\n\nplc = snap7.client.Client()\nplc.connect(PLC_IP, RACK, SLOT)\n\n\n\n\n\n6.3 Algılama ve Karar Üretme\nBu aşamada ekrandan alınan ROI görüntülerinde HSV tabanlı renk analizi yapılarak mavi ve yeşil nesnelerin varlığına karar veren görüntü işleme aşaması yönetilmiştir.\n\n\n\n\n\n\nNotAlgılama ve Sınıflandırma Aşaması\n\n\n\n\n\nwith mss.mss() as sct:\n    while True:\n        t0 = time.perf_counter()\n\n        img_b = np.array(sct.grab(roı_blue))[:, :, :3]\n        img_g = np.array(sct.grab(roı_green))[:, :, :3]\n\n        hsv_b = cv2.cvtColor(img_b, cv2.COLOR_BGR2HSV)\n        hsv_g = cv2.cvtColor(img_g, cv2.COLOR_BGR2HSV)\n\n        blue_mask  = cv2.inRange(hsv_b, blue_low, blue_hıgh)\n        green_mask = cv2.inRange(hsv_g, green_low, green_hıgh)\n\n        blue_px  = cv2.countNonZero(blue_mask)\n        green_px = cv2.countNonZero(green_mask)\n\n        blue  = blue_px  &gt; px_threshold\n        green = green_px &gt; px_threshold\n\n\n\n\n\n6.4 PLC Bit Güncelleme\nBu kod bloğunda ilk önce hedef bitin bulunduğu “Byte” PLC’den okunmuş, ilgili bit manipüle edildikten sonra tekrar yazılarak aynı adresteki diğer bitlerin korunması sağlanmıştır. Snap7 kütüphanesi ve S7 protokolü verileri Byte (8-bit) tabanlı işler. Doğrudan yazma işleminde hedef byte içerisindeki diğer 7 bit sıfırlanabilmektedir.\n\n\n\n\n\n\nNotPLC Bit Güncelleme\n\n\n\n\n\n        byte_blue = bytearray(plc.mb_read(50, 1))\n        util.set_bool(byte_blue, 0, 0, blue)\n        plc.mb_write(50, 1, byte_blue)\n        \n        byte_green = bytearray(plc.mb_read(51, 1))\n        util.set_bool(byte_green, 0, 0, green)\n        plc.mb_write(51, 1, byte_green)\n\n\n\n\n\n6.5 Periyodik Durum Log\nBu kod bloğu ile ana döngüden bağımsız olarak, saniyede 2 kez durum verileri (piksel sayıları ve lojik sonuçlar) konsola yazdırılmıştır.\n\n\n\n\n\n\nNotPeriyodik Durum Log\n\n\n\n\n\n        now = time.time()\n        if now - last_log &gt; 0.5:\n            print(f\"BLUE px={blue_px:5d} thr={PIXEL_THR} -&gt; {int(blue)} | GREEN px={green_px:5d} -&gt; {int(green)}\")\n            last_log = now\n\n\n\n\n\n6.6 Debug Amaçlı Görüntü Gösterimi\nBu aşamada ham görüntüler ile birlikte elde edilen maskeler ekrana yansıtılmıştır. Aynı zamanda klavyeden “q” harfine basınca programın manuel olarak sonlandırılabilmesi sağlanmıştır.\n\n\n\n\n\n\nNotDebug Amaçlı Görüntü Gösterimi\n\n\n\n\n\n        if show_debug:\n            cv2.imshow(\"ROI BLUE\", img_b)\n            cv2.imshow(\"BLUE MASK\", blue_mask)\n            cv2.imshow(\"ROI GREEN\", img_g)\n            cv2.imshow(\"GREEN MASK\", green_mask)\n            if cv2.waitKey(1) & 0xFF == ord('q'):\n                break\n\n\n\n\n\n6.7 Döngü Zamanlama Kontrolü\nBu kısımda düzenli veri akışı sağlamak adına, her işlem sonunda hesaplanan süre kadar bekleme uygulanmıştır.\n\n\n\n\n\n\nNotDöngü Zamanlama Kontrolü\n\n\n\n\n\n        dt = time.perf_counter() - t0\n        if dt &lt; gecen_sure: time.sleep(gecen_sure - dt)\n\n\n\n\n\n6.8 Uygulama Sonlandırma Aşaması\nProgramın en sonunda uygulama kapatılırken tüm açık pencereler ve PLC bağlantısı güvenli bir şekilde kapatılarak kaynaklar serbest bırakılmıştır.\n\n\n\n\n\n\nNotUygulama Sonlandırma Aşaması\n\n\n\n\n\ncv2.destroyAllWindows()\nplc.disconnect()\n\n\n\n\n\n\n7. Python Programı\n\n\n\n\n\n\nNotPython Kodunun Tamamını Görüntülemek için Tıklayınız.\n\n\n\n\n\nimport time\nimport cv2\nimport numpy as np\nimport mss\nimport snap7\nfrom snap7 import util\n\nPLC_IP = \"XXX.XXX.XXX.XXX\"\nRACK = 0\nSLOT = 1\n\nblue_low   = np.array([75,  30, 20])\nblue_hıgh  = np.array([140, 255, 255])\n\ngreen_low  = np.array([40,  80, 50])\ngreen_hıgh = np.array([80,  255, 255])\n\nroı_blue = {'top': 432, 'left': 692, 'width': 48, 'height': 44}\nroı_green = {'top': 565, 'left': 1253, 'width': 50, 'height': 68}\n\npx_threshold = 1200\ngecen_sure = 0.10\nlast_log = 0  \n\nshow_debug = True\n\nplc = snap7.client.Client()\nplc.connect(PLC_IP, RACK, SLOT)\n\n\nwith mss.mss() as scr:\n    while True:\n        t0 = time.perf_counter()\n\n        img_b = np.array(scr.grab(roı_blue))[:, :, :3]\n        img_g = np.array(scr.grab(roı_green))[:, :, :3]\n\n        hsv_b = cv2.cvtColor(img_b, cv2.COLOR_BGR2HSV)\n        hsv_g = cv2.cvtColor(img_g, cv2.COLOR_BGR2HSV)\n\n        blue_mask  = cv2.inRange(hsv_b, blue_low, blue_hıgh)\n        green_mask = cv2.inRange(hsv_g, green_low, green_hıgh)\n\n        blue_px  = cv2.countNonZero(blue_mask)\n        green_px = cv2.countNonZero(green_mask)\n\n        blue  = blue_px  &gt; px_threshold\n        green = green_px &gt; px_threshold\n        \n        byte_blue = bytearray(plc.mb_read(50, 1))\n        util.set_bool(byte_blue, 0, 0, blue)\n        plc.mb_write(50, 1, byte_blue)\n        \n        byte_green = bytearray(plc.mb_read(51, 1))\n        util.set_bool(byte_green, 0, 0, green)\n        plc.mb_write(51, 1, byte_green)\n\n        now = time.time()\n        if now - last_log &gt; 0.5:\n            print(f\"MAVİ px={blue_px:5d} eşik={px_threshold} -&gt; {int(blue)} | YEŞİL px={green_px:5d} -&gt; {int(green)}\")\n            last_log = now\n\n        if show_debug:\n            cv2.imshow(\"Mavi ROI\", img_b)\n            cv2.imshow(\"Mavi Maskleme\", blue_mask)\n            cv2.imshow(\"Yeşil ROI\", img_g)\n            cv2.imshow(\"Yeşil Maskeleme\", green_mask)\n            if cv2.waitKey(1) & 0xFF == ord('q'):\n                break\n\n        dt = time.perf_counter() - t0\n        if dt &lt; gecen_sure: time.sleep(gecen_sure - dt)\n\ncv2.destroyAllWindows()\nplc.disconnect()\n\n\n\n\n\n8. Sonuçlar\nGerçekleştirilen projeye dair yapılan çalışmanın video kayıtları aşağıdaki gibidir.\nFactory I/O ortamında yazılan PLC programının konveyör, start, stop, acil stop butonlarının çalışması aşağıda gösterildiği gibi kontrol edilmiştir.\n\nGerçekleştirilen projenin simülasyonuna ait video kaydı aşağıdaki gibidir."
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Blog Yazılarım",
    "section": "",
    "text": "Sıralama Öğesi\n      Varsayılan\n      \n        Başlık\n      \n      \n        Tarih - En eski\n      \n      \n        Tarih - En yeni\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nTIA Portal ve Factory I/O ile Python: Sanal Ayıklama Uygulaması\n\n\nPython Programlama ile Sanal Ayıklama Uygulaması\n\n\nPython programlama kullanarak Factory I/O ve TIA Portal haberleşmesiyle Factory I/O ortamında konveyörde bulunan hammaddeleri renklerine göre ayırma uygulaması.\n\n\n\n\n\n13 Aralık 2025\n\n\n\n\n\n\n\n\n\n\n\n\nVisual Components #1: Layout Konfigürasyonu\n\n\nVisual Components\n\n\nVisual Components Academy platformunda bulunan “Introduction to Layout Configuration” dersinin uygulaması.\n\n\n\n\n\n11 Aralık 2025\n\n\n\n\n\nEşleşen öğe yok"
  },
  {
    "objectID": "projects/sanal-akilli-ayiklama/index.html",
    "href": "projects/sanal-akilli-ayiklama/index.html",
    "title": "[Proje Başlığı: Teknik ve Tanımlayıcı]",
    "section": "",
    "text": "Proje Tanıtımı\n[Buraya projenin bitmiş halini, çalışan mekanizmayı veya yazılım arayüzünü gösteren ana görsel/video/GIF eklenecektir.]\n\n\n\nAna Görsel / Demo\n\n\n\nGenel Bakış\n[Bu bölümde projenin neden yapıldığı (Problem) ve neyi başardığı (Çözüm) anlatılmalıdır. Senior bir mühendis burayı okuduğunda projenin kapsamını 30 saniyede anlamalıdır.]\n\n\n\n\nTeknik Spesifikasyonlar\nProjenin teknik derinliğini ve kullanılan araçları hızlıca özetlemek için bu tabloyu doldurunuz.\n\n\n\nKategori\nDetaylar\n\n\n\n\nDisiplinler\n[Örn: Robotik, Gömülü Sistemler, Kontrol Teorisi]\n\n\nYazılım Yığınları\n[Örn: Python, C++, ROS2, TwinCAT]\n\n\nDonanım / Platform\n[Örn: UR5 Robot Kolu, STM32, Jetson Nano]\n\n\nHaberleşme & Protokoller\n[Örn: EtherCAT, CAN-Bus, MQTT]\n\n\nMetodoloji\n[Örn: PID Kontrol, Kinematik Analiz, CNN]\n\n\n\n\n\n\nSistem Tasarımı ve Mimari\nBu bölüm projenin “nasıl” kurgulandığını teknik bir dille açıklar.\n\n1. Sistem Mimarisi (Blok Diyagramı)\n[Görüntü işleme ise veri akış hattı; robotik ise kontrol döngüsü; PLC ise I/O haritası burada şematize edilmelidir.]\n\n\n\nSistem Diyagramı\n\n\n\n\n2. Algoritmik Yaklaşım ve Mantık\n[Projenin kalbi olan mantığı burada anlatın. Eğer robotikse kinematik denklemler; ML ise model mimarisi; otomasyon ise State Machine yapısı.]\n\nVeri/Sinyal Girişi: [Saha verilerinin veya sensör girişlerinin nasıl alındığı.]\nİşleme Katmanı: [Verinin nasıl anlamlandırıldığı ve karar mekanizması.]\nÇıktı / Eylem: [Aktüatörlerin veya sonuç ekranlarının nasıl tetiklendiği.]\n\n\n\n\n\nUygulama ve Kritik Kod Analizi\nProjenin başarısını belirleyen kritik teknik çözümlerden kesitler.\n\nKritik Algoritma / Fonksiyon\n[Burada tüm kodu değil, sadece senin mühendislik farkını ortaya koyan, optimize edilmiş veya karmaşık bir sorunu çözen kısmı paylaşmalısın.]\n// Örnek: Robotik için PID kontrol veya Gömülü sistemler için interrupt yönetimi\nvoid calculateControlSignal() {\n    // Mühendislik farkı yaratan hesaplama adımları\n}\n\n\n\n\nMühendislik Zorlukları ve Çözüm Süreçleri\n[Bu bölüm senin problem çözme yeteneğini (Troubleshooting) kanıtladığın yerdir.]\n\nTeknik Engel: [Karşılaşılan en büyük darboğaz neydi? Örn: Donanım kısıtı, yüksek gecikme süresi, veri gürültüsü.]\nAnalitik Yaklaşım: [Bu engeli aşmak için hangi testler yapıldı, hangi veriler incelendi?]\nNihai Çözüm: [Uygulanan çözüm ve elde edilen iyileştirme miktarı (Örn: %20 daha az CPU kullanımı).]\n\n\n\n\nPerformans Analizi ve Sonuçlar\nProjenin başarısı nesnel verilerle sunulmalıdır.\n\nDoğruluk/Hata Oranı: [Örn: +/- 0.5mm hassasiyet veya %95 doğruluk.]\nVerimlilik: [Örn: Çevrim süresi analizi veya güç tüketimi değerleri.]\nGelecek Çalışmalar: [Sistem daha fazla nasıl geliştirilebilir veya hangi eksikler var?]\n\n\n\n\nProje Kaynakları\n\nGitHub Linki / Repozitör\nTeknik Rapor / Makale (PDF)\nKullanılan Veri Seti / Kütüphaneler"
  },
  {
    "objectID": "projects/index.html",
    "href": "projects/index.html",
    "title": "Mühendislik Projeleri",
    "section": "",
    "text": "Sıralama Öğesi\n      Varsayılan\n      \n        Başlık\n      \n      \n        Tarih - En eski\n      \n      \n        Tarih - En yeni\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n[Proje Başlığı: Teknik ve Tanımlayıcı]\n\n2 dakika\n\n\nAlan 1\n\nAlan 2\n\nTeknoloji\n\n\n\n\nInvalid Date\n\n\n\n\n\n\n\n\n\n\n\n\n\nCODESYS Tabanlı Trafik Işığı Kontrol Sistemi\n\n6 dakika\n\n\nEndüstriyel Otomasyon\n\nPLC\n\nCODESYS\n\nVisu\n\nST\n\n\n\n\n19 Aralık 2025\n\n\n\n\n\n\nEşleşen öğe yok"
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html",
    "href": "projects/trafik-light-control-codesys/index.html",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "",
    "text": "Bu çalışmada CODESYS platformu üzerinden yapısal metin (Structured Text - ST) ile bir kavşakta bulunan trafik ışıkları simüle edilmiştir. Programlama yapısında “Sonlu Durum Makinesi (Finite State Machine - FSM) yaklaşımı uygulanmıştır."
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html#özet",
    "href": "projects/trafik-light-control-codesys/index.html#özet",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "",
    "text": "Bu çalışmada CODESYS platformu üzerinden yapısal metin (Structured Text - ST) ile bir kavşakta bulunan trafik ışıkları simüle edilmiştir. Programlama yapısında “Sonlu Durum Makinesi (Finite State Machine - FSM) yaklaşımı uygulanmıştır."
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html#genel-bakış",
    "href": "projects/trafik-light-control-codesys/index.html#genel-bakış",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "1. Genel Bakış",
    "text": "1. Genel Bakış\nBu proje bir kavşakta bulunan trafik ışıklarının birbiriyle bağlantı çalışmasının simülasyonudur. CODESYS üzerinde ST programlama ile birlikte “CODESYS Target Visualization” objesiyle görsel olarak takip edilebilecek şekilde hazırlanmıştır.\nTemel Kazanımlar:\nST Programlama: Programlama dili olarak ST seçilmiştir. Böylelikle yapısal programlama alıştırması yapılmıştır.\nFSM Yaklaşımı: Durumlar CASE tabanlı bir FSM yapısı ile yönetilmiş, geçişler zamanlayıcı koşullarına göre tanımlanmıştır. (tkr)\nVisualization: Oluşturulan değişkenler görsel objelerle senaryoya uygun ilişkilendirilmiştir. Projenin işleyişinin takip edilebilmesi için simülasyon sahnesi oluşturulmuştur. İnsan Makine Arayüzü (Human Machine Interface - HMI) mantığına yakın bir şekilde kullanıcı etkileşimli kontrol sağlanmıştır."
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html#teknik-altyapı-ve-kullanılan-teknolojiler",
    "href": "projects/trafik-light-control-codesys/index.html#teknik-altyapı-ve-kullanılan-teknolojiler",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "2. Teknik Altyapı ve Kullanılan Teknolojiler",
    "text": "2. Teknik Altyapı ve Kullanılan Teknolojiler\nProjenin geliştirilmesinde kullanılan araçlar aşağıdaki gibidir.\n\n\n\n\n\n\n\n\nKategori\nBileşen / Teknoloji\nAçıklama\n\n\n\n\nSimülasyon Ortamı\nCODESYS V3.5 SP21 Patch 4\nOluşturulan değişkenlerin ilişkilendirilen görseller ile birlikte simülasyonu\n\n\nPLC\nCODESYS Control Win V3 x64\nMantıksal kontrol ve değişkenlerin yönetimi\n\n\nGörselleştirme Ekranı\nCODESYS TargetVisu\nÇalışma senaryosunun görsel takibi"
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html#sistem-mimarisi-ve-tasarım",
    "href": "projects/trafik-light-control-codesys/index.html#sistem-mimarisi-ve-tasarım",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "3. Sistem Mimarisi ve Tasarım",
    "text": "3. Sistem Mimarisi ve Tasarım\nSistem CODESYS ortamında hazırlanan PLC programı ile bu projeye eklenen “Visualization” objesiyle etkileşim kurmaktadır. Sistemin görsel olarak izlenebilmesi için yol ve ışık objeleri, başlatma-durdurma ve gece modu butonları oluşturulmuştur. Trafik ışıkları bulunduğu yön ve renk bilgisiyle tanımlanmıştır."
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html#algoritma-ve-kontrol-mantığı",
    "href": "projects/trafik-light-control-codesys/index.html#algoritma-ve-kontrol-mantığı",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "4. Algoritma ve Kontrol Mantığı",
    "text": "4. Algoritma ve Kontrol Mantığı\n\n4. 1. Gündüz Modu\nSimülasyon başlatıldığında sistem kapalı durumdadır ve ekranda “Sistem Kapalı” bilgisi görünmektedir. “Sistem Durdur / Başlat” butonuna basılmasıyla sistem aktif hale gelir ve gündüz trafik kontrol döngüsü çalışmaya başlamaktadır. Gündüz çalışma modunda sistem, Kuzey-Güney ve Doğu-Batı yönlerini aşağıdaki sırayla kontrol etmektedir:\n\n\n\nYön 1\nIşık Rengi\nYön 2\nIşık Rengi\nSüre\n\n\n\n\nKuzey - Güney\nYEŞİL\nDoğu - Batı\nKIRMIZI\n5 saniye\n\n\nKuzey - Güney\nSARI\nDoğu - Batı\nKIRMIZI\n2 saniye\n\n\nKuzey - Güney\nKIRMIZI\nDoğu - Batı\nYEŞİL\n5 saniye\n\n\n\nTablo 4. 1. 1\n\n\n\nYön 1\nIşık Rengi\nYön 2\nIşık Rengi\nSüre\n\n\n\n\nDoğu - Batı\nYEŞİL\nKuzey - Güney\nKIRMIZI\n5 saniye\n\n\nDoğu - Batı\nSARI\nKuzey - Güney\nKIRMIZI\n2 saniye\n\n\nDoğu - Batı\nKIRMIZI\nKuzey - Güney\nYEŞİL\n5 saniye\n\n\n\nTablo 4. 1. 2\nBu döngü, sistem durdurulasıya kadar sürekli olarak tekrar etmektedir. Geçen süre bilgisi bilgilendirme ekranı üzerinden gösterilmiştir.\n\n\n4. 2. Gece Modu\nSistem çalışırken Gece Modu etkinleştirildiğinde gündüze ait trafik döngüsü durdurulur ve tüm yönlerdeki ışıklar saniyede 2 kez yanıp söner. Gece modu devre dışı bırakıldığında sistem gündüz çalışma moduna dönmektedir.\n\n\n4. 3. Sistem Durdurma\n“Sistem Durdur / Başlat” butonuna tekrar basıldığında sistem kapanır ve başlangıç durumuna geçmektedir.\n\n\n4. 4. Kritik Mühendislik Kararı\nBurada neden X protokolünü veya Y donanımını seçtiğini teknik gerekçeleriyle belirtmelisin. Bu, mühendislik vizyonunu yansıtır.\n\n\n4. 5. Kod Yapısı\n\n\n\n\n\n\nNotDeğişkenler\n\n\n\n\n\nPROGRAM PLC_PRG\nVAR\n    xStart      : BOOL := FALSE;  \n    xNightMode  : BOOL := FALSE;\n    \n    xStep       : INT := 0;\n    tDuration   : TIME;            \n    \n    xKuzeyGuneyYesil    : BOOL;\n    xKuzeyGuneySari     : BOOL; \n    xKuzeyGuneyKirmizi  : BOOL; \n    xDoguBatiYesil      : BOOL;\n    xDoguBatiSari       : BOOL;\n    xDoguBatiKirmizi    : BOOL;\n\n    fbStepTimer         : TON;\n    fbBlinkTimer        : TON;                \nEND_VAR\n\n\n\n\n\n\n\n\n\nNotProgramming\n\n\n\n\n\nfbBlinkTimer(IN := NOT fbBlinkTimer.Q, PT := T#1S);\nfbStepTimer(IN := (xStart AND NOT xNightMode AND NOT fbStepTimer.Q), PT:= tDuration);\n\nIF xStart THEN\n    IF xNightMode THEN\n        xStep :=99;\n        xKuzeyGuneyYesil := FALSE; xKuzeyGuneyKirmizi := FALSE;\n        xDoguBatiYesil := FALSE; xDoguBatiKirmizi := FALSE;\n        IF fbBlinkTimer.ET &lt; T#500MS THEN\n            xKuzeyGuneySari := TRUE;\n            xDoguBatiSari := TRUE;\n        ELSE\n            xKuzeyGuneySari := FALSE;\n            xDoguBatiSari := FALSE; \n        END_IF\n    ELSE\n        IF xStep = 99 THEN\n            xStep :=0 ;\n        END_IF\n        CASE xStep OF\n            0: \n                xStep := 10;\n            10: \n                xKuzeyGuneyYesil := TRUE; xKuzeyGuneySari := FALSE; xKuzeyGuneyKirmizi := FALSE;\n                xDoguBatiYesil := FALSE; xDoguBatiSari := FALSE; xDoguBatiKirmizi := TRUE;\n                \n                tDuration := T#5S; \n                \n                IF fbStepTimer.Q THEN\n                    xStep := 20; \n                END_IF;\n    \n            20:\n                xKuzeyGuneyYesil := FALSE; xKuzeyGuneySari := TRUE ; xKuzeyGuneyKirmizi := FALSE;\n                xDoguBatiYesil := FALSE; xDoguBatiSari := FALSE; xDoguBatiKirmizi := TRUE;\n                \n                tDuration := T#2S; \n                \n                IF fbStepTimer.Q THEN\n                    xStep := 30; \n                END_IF;         \n                 \n            30: (* K-G Kırmızı, D-B Yeşil *)\n                xKuzeyGuneyYesil := FALSE; xKuzeyGuneySari := FALSE ; xKuzeyGuneyKirmizi := TRUE;\n                xDoguBatiYesil := TRUE; xDoguBatiSari := FALSE; xDoguBatiKirmizi := FALSE;\n                \n                tDuration := T#5S; \n                \n                IF fbStepTimer.Q THEN\n                    xStep := 40; \n                END_IF;            \n    \n            40: (* K-G Kırmızı, D-B Sarı *)\n                xKuzeyGuneyYesil := FALSE; xKuzeyGuneySari := FALSE ; xKuzeyGuneyKirmizi := TRUE;\n                xDoguBatiYesil := FALSE; xDoguBatiSari := TRUE; xDoguBatiKirmizi := FALSE;\n                \n                tDuration := T#2S; \n                \n                IF fbStepTimer.Q THEN\n                    xStep := 10; \n                END_IF;\n        END_CASE\n    END_IF;\nELSE\n    xStep := 0;\n    xKuzeyGuneyYesil := FALSE; xKuzeyGuneySari := FALSE; xKuzeyGuneyKirmizi := FALSE;\n    xDoguBatiYesil := FALSE; xDoguBatiSari := FALSE; xDoguBatiKirmizi := FALSE;\nEND_IF;"
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html#karşılaşılan-teknik-zorluklar-ve-çözüm-süreçleri",
    "href": "projects/trafik-light-control-codesys/index.html#karşılaşılan-teknik-zorluklar-ve-çözüm-süreçleri",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "5. Karşılaşılan Teknik Zorluklar ve Çözüm Süreçleri",
    "text": "5. Karşılaşılan Teknik Zorluklar ve Çözüm Süreçleri\n\nSorun 1: Görsel Bileşenlerin Hizalanması\nDurum: Eklenen bileşenlerin görsel şemaya uygun bir şekilde birbirleriyle simetrik ve estetik bir görünümde olması gerekiyordu.\nÇözüm: Bileşenler sınırlı bir alan içerisine rounded-rectangle içerisine çizildi. Böylece “Visualization” ekranında bileşenlerin birbirine ve içerisinde bulunduğu sınır bölgeye göre yatay ve dikey hizalamalar gerçekleştirildi. Daha sonra eklenen “rounded-rectangle” bileşeni görünmez yapıldı.\n\n\n\n\n\n\nGörsel 1\n\n\n\n\n\n\n\nGörsel 2\n\n\n\n\n\n\n\nSorun 2: Durum Ekranı\nDurum: Simülasyon ekranında tasarlanan güzergahlar için güzergaha göre trafik ışığının ne renk olduğu ekranda gösterilmesi gerekiyordu.\nÇözüm: Trafik ışıklarının renklerine ait kod blokları “Text List” ile ilişkilendirildi. Daha sonra ekranda “Text Field” içerisine “Dynamic Texts” özelliği kullanılarak simülasyon içerisinde durumlar ekranda gösterildi. İki farklı güzergah olduğu için her iki güzergah için bu çözüm uygulandı.\n\n\n\n\n\n\nStates V1\n\n\n\n\n\n\n\nStates V1\n\n\n\n\n\n\n\n\n\nDynamics Text V1\n\n\n\n\n\n\n\nDynamics Text V2"
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html#analiz-ve-sonuçlar",
    "href": "projects/trafik-light-control-codesys/index.html#analiz-ve-sonuçlar",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "6. Analiz ve Sonuçlar",
    "text": "6. Analiz ve Sonuçlar"
  },
  {
    "objectID": "projects/trafik-light-control-codesys/index.html#referanslar-ve-dokümantasyon-dokümantasyon-ve-kaynaklar",
    "href": "projects/trafik-light-control-codesys/index.html#referanslar-ve-dokümantasyon-dokümantasyon-ve-kaynaklar",
    "title": "CODESYS Tabanlı Trafik Işığı Kontrol Sistemi",
    "section": "7. Referanslar ve Dokümantasyon (Dokümantasyon ve Kaynaklar)",
    "text": "7. Referanslar ve Dokümantasyon (Dokümantasyon ve Kaynaklar)\n\n  GitHub Codesys Proje Arşivi\n  Codesys Proje Dosyası (.project)\n  PLC Programlama Standartları Raporu"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "İbrahim Çapar",
    "section": "",
    "text": "Burası benim kişisel portfolyo ve blog sitem. Endüstriyel Otomasyon, Robotik ve Görüntü İşleme alanlarındaki çalışmalarımı ve projelerimi paylaşıyorum."
  },
  {
    "objectID": "index.html#hakkımda",
    "href": "index.html#hakkımda",
    "title": "İbrahim Çapar",
    "section": "",
    "text": "Burası benim kişisel portfolyo ve blog sitem. Endüstriyel Otomasyon, Robotik ve Görüntü İşleme alanlarındaki çalışmalarımı ve projelerimi paylaşıyorum."
  },
  {
    "objectID": "posts/visual-components-layout/index.html",
    "href": "posts/visual-components-layout/index.html",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "",
    "text": "Endüstriyel otomasyon, Robotik ve Dijital İkiz (Digital Twin) alanında yetkinliklerimi geliştirmek için Visual Components programını öğrenmeye başladım. Bu yazıda, Visual Component Academy de bulunan Layout Configuration dersini takip ederek oluşturduğum ilk düzenlemeyi paylaşıyorum."
  },
  {
    "objectID": "posts/visual-components-layout/index.html#giriş",
    "href": "posts/visual-components-layout/index.html#giriş",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "",
    "text": "Endüstriyel otomasyon, Robotik ve Dijital İkiz (Digital Twin) alanında yetkinliklerimi geliştirmek için Visual Components programını öğrenmeye başladım. Bu yazıda, Visual Component Academy de bulunan Layout Configuration dersini takip ederek oluşturduğum ilk düzenlemeyi paylaşıyorum."
  },
  {
    "objectID": "posts/visual-components-layout/index.html#neler-yaptım",
    "href": "posts/visual-components-layout/index.html#neler-yaptım",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "Neler Yaptım?",
    "text": "Neler Yaptım?\nBu çalışmada temel olarak şu adımları uyguladım:\n\ne-Catalog Kullanımı: Kütüphaneden konveyör, besleyici (Feeder), eklemli robot (Articulated Robot), torna tezgahı (Lathe), fens (Fence), masa (Table) ve rafların (Warehouse Shelf) sahneye eklenmesi.\nPnP (Plug and Play): Bileşenlerin birbirine otomatik olarak bağlanması ve hizalanması.\nLayout Düzenleme: Eklenen bileşenlerin “Clone” ile çoğaltılması, “Move” ile yerleşimlerin ayarlanması, bileşen ayarları (Component Properties) kullanarak bileşenlerin açılarının ayarlanması.\nProcess Flow Editor: Oluşturulan senaryoda prosesin hangi işlem sırası ile gerçekleştirileceğinin ayarlanması.\nInteract: Sahneye eklenen robotun eksen hareketlerinin mause ile hareket ettirilerek çalışma uzayının (Work Envelope) incelenmesi.\nStatements: Oluşturulan senaryo kapsamında konveyör hattından gelen Piston Head ile raftan alınan Piston Rod bileşenlerinin, Process Node kullanılarak A masasında montajının yapılması, ardından B masasında son işlemlerin tamamlanarak ürünün sistemden çıkışının sağlanması.\nSimülasyon Testi: Oluşturulan senaryonun gözlemlenmesi ve hataların giderilmesi."
  },
  {
    "objectID": "posts/visual-components-layout/index.html#ekran-görüntüsü",
    "href": "posts/visual-components-layout/index.html#ekran-görüntüsü",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "Ekran Görüntüsü",
    "text": "Ekran Görüntüsü\nAşağıda kendi oluşturduğum simülasyonun görüntüsü yer almaktadır:"
  },
  {
    "objectID": "posts/visual-components-layout/index.html#simülasyon-adımları",
    "href": "posts/visual-components-layout/index.html#simülasyon-adımları",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "Simülasyon Adımları",
    "text": "Simülasyon Adımları"
  },
  {
    "objectID": "posts/visual-components-layout/index.html#çıkarımlarım-key-takeaways",
    "href": "posts/visual-components-layout/index.html#çıkarımlarım-key-takeaways",
    "title": "Visual Components #1: Layout Konfigürasyonu",
    "section": "Çıkarımlarım (Key Takeaways)",
    "text": "Çıkarımlarım (Key Takeaways)\n\nVisual Components’in manuel pozisyonlama yerine PnP (Plug and Play) özelliği tasarım sürecini kolaylaştırıyor. Ayrıca “Snap” özelliği ile bileşenleri birbiriyle kolay bir şekilde birleştirilmesini sağlıyor.\nVisual Components’in içerisinde bulunan e-Catalog ile birçok önemli markalara ait ürünlerin aynı ortamda bulunması gerçek durumları simüle etmeyi kolaylaştırıyor.\nProcess Flow Editor ile, layoutta bulunan bileşenlerin prosesi hangi sıra ve ilişki ile gerçekleştireceği kolay bir şekilde yönetiliyor. Bununla birlikte “Statement” kullanarak daha gelişmiş sonuçlar elde edilebiliyor.\nDijital İkiz yaklaşımına insan bileşenini de üretim sürecine dahil ederek prosesi daha gelişmiş bir şekilde simüle edilmesini sağlıyor.\n\n\nKaynak: Bu çalışma Visual Components Academy dersleri baz alınarak yapılmıştır."
  },
  {
    "objectID": "notes/technical/index.html",
    "href": "notes/technical/index.html",
    "title": "Teknik Referanslar",
    "section": "",
    "text": "Bu bölümde, mühendislik disiplinlerine dair kalıcı teknik bilgiler ve referans dökümanları yer almaktadır.\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\nKonu Başlığı\nSon Güncelleme\nKategoriler\n\n\n\n\n\nEşleşen öğe yok"
  }
]